/*
CF_NOCLIP			= 1 << 0,		// No clipping, walk through barriers.
CF_GODMODE			= 1 << 1,		// No damage, no health loss.
CF_NOVELOCITY		= 1 << 2,		// Not really a cheat, just a debug aid.
CF_NOTARGET			= 1 << 3,		// [RH] Monsters don't target
CF_FLY				= 1 << 4,		// [RH] Flying player
CF_CHASECAM			= 1 << 5,		// [RH] Put camera behind player
CF_FROZEN			= 1 << 6,		// [RH] Don't let the player move
CF_REVERTPLEASE		= 1 << 7,		// [RH] Stick camera in player's head if (s)he moves
CF_STEPLEFT			= 1 << 9,		// [RH] Play left footstep sound next time
CF_FRIGHTENING		= 1 << 10,		// [RH] Scare monsters away
CF_INSTANTWEAPSWITCH= 1 << 11,		// [RH] Switch weapons instantly
CF_TOTALLYFROZEN	= 1 << 12,		// [RH] All players can do is press +use
CF_PREDICTING		= 1 << 13,		// [RH] Player movement is being predicted
CF_INTERPVIEW		= 1 << 14,		// [RH] view was changed outside of input, so interpolate one frame
CF_DRAIN			= 1 << 16,		// Player owns a drain powerup
CF_HIGHJUMP			= 1 << 18,		// more Skulltag flags. Implementation not guaranteed though. ;)
CF_REFLECTION		= 1 << 19,
CF_PROSPERITY		= 1 << 20,
CF_DOUBLEFIRINGSPEED= 1 << 21,		// Player owns a double firing speed artifact
CF_EXTREMELYDEAD	= 1 << 22,		// [RH] Reliably let the status bar know about extreme deaths.
CF_INFINITEAMMO		= 1 << 23,		// Player owns an infinite ammo artifact
CF_BUDDHA2			= 1 << 24,		// [MC] Absolute buddha. No voodoo can kill it either.
CF_GODMODE2			= 1 << 25,		// [MC] Absolute godmode. No voodoo can kill it either.
CF_BUDDHA			= 1 << 27,		// [SP] Buddha mode - take damage, but don't die
CF_NOCLIP2			= 1 << 30,		// [RH] More Quake-like noclip
*/

class CheatingFlight : Powerup
{
	Default
	{
		Powerup.Duration -99999;
		+INVENTORY.HUBPOWER
	}

	override void InitEffect ()
	{
		Super.InitEffect();
		Owner.bFly = true;
		Owner.bNoGravity = true;
	}

	override void EndEffect ()
	{
		Super.EndEffect();
		if (Owner == NULL || Owner.player == NULL)
		{
			return;
		}

		if (!(Owner.bFlyCheat))
		{
			Owner.bFly = false;
			Owner.bNoGravity = false;
		}
	}
}

class YouSpinMyHeadRightRoundRightRoundLikeARecordBabyRightRoundRightRound : Powerup
{
	int storedposZ, YouAreGoingIntoOrbit;
	bool DownDown;
	
	Default
	{
		Powerup.Duration -99999;
		+INVENTORY.HUBPOWER
	}

	override void InitEffect ()
	{
		Super.InitEffect();
		S_ChangeMusic("");
		storedposZ = Owner.pos.z;
	}

	override void EndEffect ()
	{
		Super.EndEffect();
		if (Owner == NULL || Owner.player == NULL)
		{
			return;
		}

		if (!(Owner.bFlyCheat))
		{
			Owner.bFly = true;
			Owner.bNoGravity = true;
		}
	}
	
	override void Tick()
	{
		Super.Tick();
		Owner.Speed = 0;
		Owner.Pitch = 0;
		Owner.bFly = true;
		Owner.bNoGravity = true;
		if (level.time > YouAreGoingIntoOrbit)
		{
			if (!DownDown)
			{
				Owner.A_StartSound("vengaboys/up", CHAN_BODY);
				Owner.SetOrigin(owner.pos+(0,0,300), false);
				DownDown = true;
			}
			else
			{
				Owner.A_StartSound("vengaboys/down", CHAN_BODY);
				Owner.SetOrigin(owner.pos-(0,0,300),false);
				DownDown = false;
			}
			
			YouAreGoingIntoOrbit = level.time + 30;
		}
		Owner.A_Print("It's disco time!");
	}
}

extend class PostalDude
{
	//yougogirl, buttsauce, yougottabefuckingkidding
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// Cheat Detector, used for cheats other than the "give all"
	// the give cheat sound is played in CheatGive.
	//
	// Plays a sound everytime the player enters a cheat.
	// It works in console, and in realtime aswell.
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	virtual void CheatDetector()
	{
		if ((player.cheats & CF_GODMODE) || (player.cheats & CF_GODMODE2))
		{
			if (PlayerData.P_GodMode != true)
			{
				A_PlaySound("dude/sissy", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_GodMode = true;
			}
		}
		else
		{
			if (PlayerData.P_GodMode == true)
			{
				A_PlaySound("dudeline5", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_GodMode = false;
			}
		}
			
			
		// Unfortunately there's no way to reassign a cheat, most likely to prevent modders prevent players to cheat
		// So we'll just give the Player the ability to fly... that's almost the same like noclip2
		if ((player.cheats & CF_NOCLIP) || (player.cheats & CF_NOCLIP2) || (player.cheats & CF_FLY))
		{
			if (PlayerData.P_NoClip != true)
			{
				A_PlaySound("cheater", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				GiveInventory("CheatingFlight",1);
				PlayerData.P_NoClip = true;
			}
		}
		else
		{
			if (PlayerData.P_NoClip == true)
			{
				A_PlaySound("cheater", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				TakeInventory("CheatingFlight",1);
				PlayerData.P_NoClip = false;
			}
		}
		
		
		
		if ((player.cheats & CF_NOTARGET))
		{
			if (PlayerData.P_NoTarget != true)
			{
				A_PlaySound("dudeline63", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_NoTarget = true;
			}
		}
		else
		{
			if (PlayerData.P_NoTarget == true)
			{
				A_PlaySound("dudeline45", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_NoTarget = false;
			}
		}
		
		
		//I bet no one really uses this cheat, but who cares right?
		if ((player.cheats & CF_FRIGHTENING))
		{
			if (PlayerData.P_Frightening != true)
			{
				A_PlaySound("dudeline12", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_Frightening = true;
			}
		}
		else
		{
			if (PlayerData.P_Frightening == true)
			{
				A_PlaySound("dudeline9", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_Frightening = false;
			}
		}
	
	}
	
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// DeathThink, removed forced angle viewing towards the killer
	// so the player can freely look around.
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	override void DeathThink ()
	{
		let player = self.player;
		
		//int dir;
		//double delta;

		player.Uncrouch();
		TickPSprites();
			
		if (player.damagecount)
		{
			player.damagecount--;
		}
		if (player.poisoncount)
		{
			player.poisoncount--;
		}		

		if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				let PlayerDude = PostalDude(self);
				let a = DummyDude(PlayerDude.DummyCorpse);
				
				if (a) a.Multiplayer = true;
				
				if (PlayerDude)
				{
					PlayerDude.PlayerData.SpawnedOnce = false;
					PlayerDude.PlayerData.Suicide = false;
					PlayerDude.MissileOnce = false;
					PlayerDude.isDead = false;
					PlayerDude.Suicided = false;
				}
				Speed = Default.Speed;
				JumpZ = Default.JumpZ;
				A_TakeInventory("CameraRunner", 1);
				A_GiveInventory("HUDViewable", 1);
				
				if (PlayerDude)
					PlayerDude.DummyCorpseSpawned = false;
				
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
	}
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// PlayerThink, edited to make the player be able to see around
	// while being dead. Also added Postal bobbing style (Unreal)
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	float BobTime;
	
	override void PlayerThink()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		// Needed for Bob_Postal
		BobTime += Vel.XY.Length() / 5;
		
		CheckFOV();

		if (player.inventorytics)
		{
			player.inventorytics--;
		}
		CheckCheats();

		if (bJustAttacked)
		{ // Chainsaw/Gauntlets attack auto forward motion
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}

		bool totallyfrozen = CheckFrozen();

		// Handle crouching
		CheckCrouch(totallyfrozen);
		CheckMusicChange();
		
		////////////////////////////////////////////////////////////////
		// PlayerThink only edited here
		////////////////////////////////////////////////////////////////
		let PlayerDude = PostalDude(self);
		
		if (player.playerstate == PST_DEAD)
		{
			Speed = 0;
			
			if (PlayerDude)
				PlayerDude.isDead = true;
			
			A_GiveInventory("CameraRunner", 1);
			A_TakeInventory("HUDViewable",1);
			
			if (PlayerDude.PlayerData && PlayerDude.PlayerData.Suicide)
				PlayerDude.PlayerData.Suicide = false;
			
			if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
			{
				if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
				{	
					let a = DummyDude(PlayerDude.DummyCorpse);
				
					if (a) a.Multiplayer = true;
					
					if (PlayerDude)
					{
						PlayerDude.PlayerData.SpawnedOnce = false;
						PlayerDude.PlayerData.Suicide = false;
						PlayerDude.MissileOnce = false;
						PlayerDude.isDead = false;
						PlayerDude.Suicided = false;
					}
					Speed = Default.Speed;
					JumpZ = Default.JumpZ;
					A_TakeInventory("CameraRunner", 1);
					A_GiveInventory("HUDViewable", 1);
					
					if (PlayerDude)
						PlayerDude.DummyCorpseSpawned = false;
					
					player.cls = NULL;		// Force a new class if the player is using a random class
					player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
					if (special1 > 2)
					{
						special1 = 0;
					}
				}
			}
		}
		else
		{
			if (PlayerDude.PlayerData && PlayerDude)
			{
				// prevent the player from crouching when suiciding
				if (PlayerDude.PlayerData.Suicide == true)
				{
					player.uncrouch();
				}
			}
			
			if (PlayerDude.DummyCorpse && PlayerDude && PlayerDude.PlayerData)
			{
				PlayerDude.PlayerData.SpawnedOnce = false;
				PlayerDude.PlayerData.Suicide = false;
				PlayerDude.MissileOnce = false;
				PlayerDude.isDead = false;
				PlayerDude.Suicided = false;
				Speed = Default.Speed;
				JumpZ = Default.JumpZ;
				PlayerDude.DummyCorpse.Destroy();
				A_TakeInventory("CameraRunner", 1);
				A_GiveInventory("HUDViewable", 1);
				PlayerDude.DummyCorpseSpawned = false;
			}	
		}
		
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		
		if (player.jumpTics != 0)
		{
			player.jumpTics--;
			if (player.onground && player.jumpTics < -18)
			{
				player.jumpTics = 0;
			}
		}
		if (player.morphTics && !(player.cheats & CF_PREDICTING))
		{
			MorphPlayerThink ();
		}

		CheckPitch();
		HandleMovement();
		CalcHeight ();

		if (!(player.cheats & CF_PREDICTING))
		{
			CheckEnvironment();
			// Note that after this point the PlayerPawn may have changed due to getting unmorphed or getting its skull popped so 'self' is no longer safe to use.
			// This also must not read mo into a local variable because several functions in this block can change the attached PlayerPawn.
			player.mo.CheckUse();
			player.mo.CheckUndoMorph();
			// Cycle psprites.
			player.mo.TickPSprites();
			// Other Counters
			if (player.damagecount)	player.damagecount--;
			if (player.bonuscount) player.bonuscount--;

			if (player.hazardcount)
			{
				player.hazardcount--;
				if (!(Level.maptime % player.hazardinterval) && player.hazardcount > 16*TICRATE)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}
			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
		}
	}
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// Plays a sound everytime the player enters a cheat.
	// It's also edited to give Kevlar, and not Doom's armor.
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	override void CheatGive (String name, int amount)
	{
		int i;
		Class<Inventory> type;
		let player = self.player;
		
		A_PlaySound("cheater", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
		
		if (player.mo == NULL || player.health <= 0)
		{
			return;
		}

		int giveall = ALL_NO;
		if (name ~== "all")
		{
			giveall = ALL_YES;
		}
		else if (name ~== "everything")
		{
			giveall = ALL_YESYES;
		}

		if (name ~== "health")
		{
			if (amount > 0)
			{
				health += amount;
				player.health = health;
			}
			else
			{
				player.health = health = GetMaxHealth(true);
			}
		}

		if (giveall || name ~== "backpack")
		{
			// Select the correct type of backpack based on the game
			type = (class<Inventory>)(gameinfo.backpacktype);
			if (type != NULL)
			{
				GiveInventory(type, 1, true);
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "ammo")
		{
			// Find every unique type of ammo. Give it to the player if
			// he doesn't have it already, and set each to its maximum.
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let ammotype = (class<Ammo>)(AllActorClasses[i]);

				if (ammotype && GetDefaultByType(ammotype).GetParentAmmo() == ammotype)
				{
					let ammoitem = FindInventory(ammotype);
					if (ammoitem == NULL)
					{
						ammoitem = Inventory(Spawn (ammotype));
						ammoitem.AttachToOwner (self);
						ammoitem.Amount = ammoitem.MaxAmount;
					}
					else if (ammoitem.Amount < ammoitem.MaxAmount)
					{
						ammoitem.Amount = ammoitem.MaxAmount;
					}
				}
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "armor")
		{
			if (gameinfo.gametype != GAME_Hexen)
			{
				let armoritem = BasicArmorPickup(Spawn("PostalBrownKevlar"));
				armoritem.SaveAmount = 100*deh.BlueAC;
				armoritem.SavePercent = gameinfo.Armor2Percent > 0 ? gameinfo.Armor2Percent * 100 : 50;
				if (!armoritem.CallTryPickup (self))
				{
					armoritem.Destroy ();
				}
			}
			else
			{
				for (i = 0; i < 4; ++i)
				{
					let armoritem = Inventory(Spawn("HexenArmor"));
					armoritem.health = i;
					armoritem.Amount = 0;
					if (!armoritem.CallTryPickup (self))
					{
						armoritem.Destroy ();
					}
				}
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "keys")
		{
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				if (AllActorClasses[i] is "Key")
				{
					let keyitem = GetDefaultByType (AllActorClasses[i]);
					if (keyitem.special1 != 0)
					{
						let item = Inventory(Spawn(AllActorClasses[i]));
						if (!item.CallTryPickup (self))
						{
							item.Destroy ();
						}
					}
				}
			}
			if (!giveall)
				return;
		}

		if (giveall || name ~== "weapons")
		{
			let savedpending = player.PendingWeapon;
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<Weapon>)(AllActorClasses[i]);
				if (type != null && type != "Weapon")
				{
					// Don't give replaced weapons unless the replacement was done by Dehacked.
					let rep = GetReplacement(type);
					if (rep == type || rep is "DehackedPickup")
					{
						// Give the weapon only if it is set in a weapon slot.
						if (player.weapons.LocateWeapon(type))
						{
							readonly<Weapon> def = GetDefaultByType (type);
							if (giveall == ALL_YESYES || !def.bCheatNotWeapon)
							{
								GiveInventory(type, 1, true);
							}
						}
					}
				}
			}
			player.PendingWeapon = savedpending;

			if (!giveall)
				return;
		}

		if (giveall || name ~== "artifacts")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				type = (class<Inventory>)(AllActorClasses[i]);
				if (type!= null)
				{
					let def = GetDefaultByType (type);
					if (def.Icon.isValid() && def.MaxAmount > 1 &&
						!(type is "PuzzleItem") && !(type is "Powerup") && !(type is "Ammo") &&	!(type is "Armor"))
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
						{
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
						}
					}
				}
			}
			if (!giveall)
				return;
		}

		if (giveall || name ~== "puzzlepieces")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<PuzzleItem>)(AllActorClasses[i]);
				if (type != null)
				{
					let def = GetDefaultByType (type);
					if (def.Icon.isValid())
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
						{
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
						}
					}
				}
			}
			if (!giveall)
				return;
		}

		if (giveall)
			return;

		type = name;
		if (type == NULL)
		{
			if (PlayerNumber() == consoleplayer)
				A_Log(String.Format("Unknown item \"%s\"\n", name));
		}
		else
		{
			GiveInventory(type, amount, true);
		}
		return;
	}
	
	// Removes any weapons that normally cannot be equipped by Postal Dude, i.e.: Doom's Chainsaw
	
	virtual void CheckForNonPostalWeapons ()
	{
		class<weapon> PostWeapon = "PostalWeapon";
		
		if (!(Player.ReadyWeapon is PostWeapon))
		{
			Player.PendingWeapon = Weapon(FindInventory("PostHands"));
		}
	}
	
	override Vector2 BobWeapon (double ticfrac)
	{
		Vector2 p1, p2, r;
		Vector2 result;

		float bobtarget;

		let player = self.player;
		if (!player) return (0, 0);
		let weapon = player.ReadyWeapon;

		if (weapon == null || weapon.bDontBob)
		{
			return (0, 0);
		}

		// [XA] Get the current weapon's bob properties.
		int bobstyle = weapon.BobStyle;
		double BobSpeed = (weapon.BobSpeed * 128);
		double Rangex = weapon.BobRangeX;
		double Rangey = weapon.BobRangeY;

		for (int i = 0; i < 2; i++)
		{
			// Bob the weapon based on movement speed. ([SP] And user's bob speed setting)
			double angle = (BobSpeed * player.GetWBobSpeed() * 35 /	TICRATE*(Level.maptime - 1 + i)) * (360. / 8192.);
			
			// [RH] Smooth transitions between bobbing and not-bobbing frames.
			// This also fixes the bug where you can "stick" a weapon off-center by
			// shooting it when it's at the peak of its swing.
			bobtarget = double((player.WeaponState & WF_WEAPONBOBBING) ? player.bob : 0.);
			if (curbob != bobtarget)
			{
				if (abs(bobtarget - curbob) <= 1)
				{
					curbob = bobtarget;
				}
				else
				{
					double zoom = MAX(1., abs(curbob - bobtarget) / 40);
					if (curbob > bobtarget)
					{
						curbob -= zoom;
					}
					else
					{
						curbob += zoom;
					}
				}
			}
			
			//[SP] Added in decorate player.viewbob checks
			double bobx = (player.bob * Rangex * ViewBob);
			double boby = (player.bob * Rangey * ViewBob);
			
			if (curbob != 0)
			{
				// Needed for Bob_Postal
				Double BobSpeed = weapon.BobSpeed * 128;
				Double BobAngle = (BobSpeed * player.GetWBobSpeed() * (BobTime - 1 + i)) * (360. / 8192.);
				
				switch (bobstyle)
				{
				case Bob_Normal:
					r.X = 1.5 * BobX * cos(BobAngle);	
					r.Y = BobY * sin(2.f * BobAngle);
					break;
					
				/* Original
				case Bob_Normal:
					r.X = bobx * cos(angle);
					r.Y = boby * abs(sin(angle));
					break;
				*/
				
				case Bob_Inverse:
					r.X = bobx*cos(angle);
					r.Y = boby * (1. - abs(sin(angle)));
					break;

				case Bob_Alpha:
					r.X = bobx * sin(angle);
					r.Y = boby * abs(sin(angle));
					break;

				case Bob_InverseAlpha:
					r.X = bobx * sin(angle);
					r.Y = boby * (1. - abs(sin(angle)));
					break;

				case Bob_Smooth:
					r.X = bobx*cos(angle);
					r.Y = 0.5f * (boby * (1. - (cos(angle * 2))));
					break;

				case Bob_InverseSmooth:
					r.X = bobx*cos(angle);
					r.Y = 0.5f * (boby * (1. + (cos(angle * 2))));
				
				/*
				case Bob_Postal:
					r.X = 1.5 * BobX * cos(BobAngle);	
					r.Y = BobY * sin(2.f * BobAngle);
					break;
				*/
				}
				
			}
			else
			{
				//r = (BobX, BobY);
			}
			
			
			if (i == 0) p1 = r; else p2 = r;
			
			
		}
		return p1 * (1. - ticfrac) + p2 * ticfrac;
	}
	
	override void MovePlayer ()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.

		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor*= level.aircontrol;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			if (forwardmove)
			{
				Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
				ForwardThrust(forwardmove, Angle);
			}
			if (sidemove)
			{
				let a = Angle - 90;
				Bob(a, cmd.sidemove * bobfactor / 256., false);
				Thrust(sidemove, a);
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}
	}
	
	override void CrouchMove(int direction)
	{
		let player = self.player;
		
		double defaultheight = FullHeight;
		double savedheight = Height;
		double crouchspeed = direction * 0.199999;
		double oldheight = player.viewheight;

		player.crouchdir = direction;
		player.crouchfactor += crouchspeed;

		// check whether the move is ok
		Height  = defaultheight * player.crouchfactor;
		if (!TryMove(Pos.XY, false, NULL))
		{
			Height = savedheight;
			if (direction > 0)
			{
				// doesn't fit
				player.crouchfactor -= crouchspeed;
				return;
			}
		}
		Height = savedheight;

		player.crouchfactor = clamp(player.crouchfactor, 0.47, 1);
		player.viewheight = ViewHeight * player.crouchfactor;
		player.crouchviewdelta = player.viewheight - ViewHeight;

		// Check for eyes going above/below fake floor due to crouching motion.
		CheckFakeFloorTriggers(pos.Z + oldheight, true);
	}
	
}
