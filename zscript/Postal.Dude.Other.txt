/*
CF_NOCLIP			= 1 << 0,		// No clipping, walk through barriers.
CF_GODMODE			= 1 << 1,		// No damage, no health loss.
CF_NOVELOCITY		= 1 << 2,		// Not really a cheat, just a debug aid.
CF_NOTARGET			= 1 << 3,		// [RH] Monsters don't target
CF_FLY				= 1 << 4,		// [RH] Flying player
CF_CHASECAM			= 1 << 5,		// [RH] Put camera behind player
CF_FROZEN			= 1 << 6,		// [RH] Don't let the player move
CF_REVERTPLEASE		= 1 << 7,		// [RH] Stick camera in player's head if (s)he moves
CF_STEPLEFT			= 1 << 9,		// [RH] Play left footstep sound next time
CF_FRIGHTENING		= 1 << 10,		// [RH] Scare monsters away
CF_INSTANTWEAPSWITCH= 1 << 11,		// [RH] Switch weapons instantly
CF_TOTALLYFROZEN	= 1 << 12,		// [RH] All players can do is press +use
CF_PREDICTING		= 1 << 13,		// [RH] Player movement is being predicted
CF_INTERPVIEW		= 1 << 14,		// [RH] view was changed outside of input, so interpolate one frame
CF_DRAIN			= 1 << 16,		// Player owns a drain powerup
CF_HIGHJUMP			= 1 << 18,		// more Skulltag flags. Implementation not guaranteed though. ;)
CF_REFLECTION		= 1 << 19,
CF_PROSPERITY		= 1 << 20,
CF_DOUBLEFIRINGSPEED= 1 << 21,		// Player owns a double firing speed artifact
CF_EXTREMELYDEAD	= 1 << 22,		// [RH] Reliably let the status bar know about extreme deaths.
CF_INFINITEAMMO		= 1 << 23,		// Player owns an infinite ammo artifact
CF_BUDDHA2			= 1 << 24,		// [MC] Absolute buddha. No voodoo can kill it either.
CF_GODMODE2			= 1 << 25,		// [MC] Absolute godmode. No voodoo can kill it either.
CF_BUDDHA			= 1 << 27,		// [SP] Buddha mode - take damage, but don't die
CF_NOCLIP2			= 1 << 30,		// [RH] More Quake-like noclip
*/

class CheatingFlight : Powerup
{
	Default
	{
		Powerup.Duration -99999;
		+INVENTORY.HUBPOWER
	}

	override void InitEffect ()
	{
		Super.InitEffect();
		Owner.bFly = true;
		Owner.bNoGravity = true;
	}

	override void EndEffect ()
	{
		Super.EndEffect();
		if (Owner == NULL || Owner.player == NULL)
		{
			return;
		}

		if (!(Owner.bFlyCheat))
		{
			Owner.bFly = false;
			Owner.bNoGravity = false;
		}
	}
}

class YouSpinMyHeadRightRoundRightRoundLikeARecordBabyRightRoundRightRound : Powerup
{
	Default
	{
		Powerup.Duration -99999;
		+INVENTORY.HUBPOWER
	}

	override void InitEffect ()
	{
		Super.InitEffect();
		S_ChangeMusic("spinme");
		class<actor> krotchytoy = "giantkrotchytoy";
		for (int i = 0; i < 100; i++)
		{
			int randomm = random(-i,i);
			Actor krr = spawn(krotchytoy, owner.pos+(randomm,randomm,randomm), NO_REPLACE);
			krr.target = owner;
			krr.SetStateLabel("See");
		}
	}

	override void EndEffect ()
	{
		Super.EndEffect();
		if (Owner == NULL || Owner.player == NULL)
		{
			return;
		}

		if (!(Owner.bFlyCheat))
		{
			Owner.bFly = false;
			Owner.bNoGravity = false;
		}
	}
	
	override void Tick()
	{
		Super.Tick();
		Owner.Angle += 15;
		Owner.Speed = 0;
		Owner.Pitch = 0;
		Owner.A_Print("It's disco time!");
		
		if (Owner.bKILLED)
			Owner.A_Print("Gee, the fun just have only begun!");
	}
}

extend class PostalDude
{
	//yougogirl, buttsauce, yougottabefuckingkidding
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// Cheat Detector, used for cheats other than the "give all"
	// the give cheat sound is played in CheatGive.
	//
	// Plays a sound everytime the player enters a cheat.
	// It works in console, and in realtime aswell.
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	virtual void CheatDetector()
	{
		if ((player.cheats & CF_GODMODE) || (player.cheats & CF_GODMODE2))
		{
			if (PlayerData.P_GodMode != true)
			{
				A_PlaySound("dude/sissy", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_GodMode = true;
			}
		}
		else
		{
			if (PlayerData.P_GodMode == true)
			{
				A_PlaySound("dudeline5", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_GodMode = false;
			}
		}
			
			
		// Unfortunately there's no way to reassign a cheat, most likely to prevent modders prevent players to cheat
		// So we'll just give the Player the ability to fly... that's almost the same like noclip2
		if ((player.cheats & CF_NOCLIP) || (player.cheats & CF_NOCLIP2) || (player.cheats & CF_FLY))
		{
			if (PlayerData.P_NoClip != true)
			{
				A_PlaySound("cheater", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				GiveInventory("CheatingFlight",1);
				PlayerData.P_NoClip = true;
			}
		}
		else
		{
			if (PlayerData.P_NoClip == true)
			{
				A_PlaySound("cheater", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				TakeInventory("CheatingFlight",1);
				PlayerData.P_NoClip = false;
			}
		}
		
		
		
		if ((player.cheats & CF_NOTARGET))
		{
			if (PlayerData.P_NoTarget != true)
			{
				A_PlaySound("dudeline63", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_NoTarget = true;
			}
		}
		else
		{
			if (PlayerData.P_NoTarget == true)
			{
				A_PlaySound("dudeline45", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_NoTarget = false;
			}
		}
		
		
		//I bet no one really uses this cheat, but who cares right?
		if ((player.cheats & CF_FRIGHTENING))
		{
			if (PlayerData.P_Frightening != true)
			{
				A_PlaySound("dudeline12", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_Frightening = true;
			}
		}
		else
		{
			if (PlayerData.P_Frightening == true)
			{
				A_PlaySound("dudeline9", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.P_Frightening = false;
			}
		}
	
	}
	
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// DeathThink, removed forced angle viewing towards the killer
	// so the player can freely look around.
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	override void DeathThink ()
	{
		let player = self.player;
		
		//int dir;
		//double delta;

		player.Uncrouch();
		TickPSprites();
			
		if (player.damagecount)
		{
			player.damagecount--;
		}
		if (player.poisoncount)
		{
			player.poisoncount--;
		}		

		if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
	}
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// PlayerThink, edited to make the player be able to see around
	// while being dead.
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	override void PlayerThink()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		CheckFOV();

		if (player.inventorytics)
		{
			player.inventorytics--;
		}
		CheckCheats();

		if (bJustAttacked)
		{ // Chainsaw/Gauntlets attack auto forward motion
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}

		bool totallyfrozen = CheckFrozen();

		// Handle crouching
		CheckCrouch(totallyfrozen);
		CheckMusicChange();
		
		////////////////////////////////////////////////////////////////
		// PlayerThink only edited here
		////////////////////////////////////////////////////////////////
		let PlayerDude = PostalDude(self);
		
		if (player.playerstate == PST_DEAD)
		{
			Speed = 0;
			
			if (PlayerDude)
				PlayerDude.isDead = true;
			
			A_GiveInventory("CameraRunner", 1);
			A_TakeInventory("HUDViewable",1);
			A_SuicideHelper();
			
			if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
			{
				if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
				{
					player.cls = NULL;		// Force a new class if the player is using a random class
					player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
					if (special1 > 2)
					{
						special1 = 0;
					}
				}
				
				let a = DummyDude(PlayerDude.DummyCorpse);
				
				if (a) a.Multiplayer = true;
				
				if (PlayerDude)
				{
					PlayerDude.PlayerData.SpawnedOnce = false;
					PlayerDude.PlayerData.Suicide = false;
					PlayerDude.MissileOnce = false;
					PlayerDude.isDead = false;
					PlayerDude.Suicided = false;
				}
				Speed = Default.Speed;
				JumpZ = Default.JumpZ;
				A_TakeInventory("CameraRunner", 1);
				A_GiveInventory("HUDViewable", 1);
				
				if (PlayerDude)
					PlayerDude.DummyCorpseSpawned = false;
				
			}
			
		}
		else
		{
			if (PlayerDude.PlayerData && PlayerDude)
			{
				// prevent the player from crouching when suiciding
				if (PlayerDude.PlayerData.Suicide == true)
				{
					player.uncrouch();
				}
			}
			
			if (PlayerDude.DummyCorpse && PlayerDude && PlayerDude.PlayerData)
			{
				PlayerDude.PlayerData.SpawnedOnce = false;
				PlayerDude.PlayerData.Suicide = false;
				PlayerDude.MissileOnce = false;
				PlayerDude.isDead = false;
				PlayerDude.Suicided = false;
				Speed = Default.Speed;
				JumpZ = Default.JumpZ;
				PlayerDude.DummyCorpse.Destroy();
				A_TakeInventory("CameraRunner", 1);
				A_GiveInventory("HUDViewable", 1);
				PlayerDude.DummyCorpseSpawned = false;
			}	
		}
		
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		
		if (player.jumpTics != 0)
		{
			player.jumpTics--;
			if (player.onground && player.jumpTics < -18)
			{
				player.jumpTics = 0;
			}
		}
		if (player.morphTics && !(player.cheats & CF_PREDICTING))
		{
			MorphPlayerThink ();
		}

		CheckPitch();
		HandleMovement();
		CalcHeight ();

		if (!(player.cheats & CF_PREDICTING))
		{
			CheckEnvironment();
			// Note that after this point the PlayerPawn may have changed due to getting unmorphed or getting its skull popped so 'self' is no longer safe to use.
			// This also must not read mo into a local variable because several functions in this block can change the attached PlayerPawn.
			player.mo.CheckUse();
			player.mo.CheckUndoMorph();
			// Cycle psprites.
			player.mo.TickPSprites();
			// Other Counters
			if (player.damagecount)	player.damagecount--;
			if (player.bonuscount) player.bonuscount--;

			if (player.hazardcount)
			{
				player.hazardcount--;
				if (!(Level.maptime % player.hazardinterval) && player.hazardcount > 16*TICRATE)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}
			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
		}
	}
	
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	// Plays a sound everytime the player enters a cheat.
	// It's also edited to give Kevlar, and not Doom's armor.
	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	
	override void CheatGive (String name, int amount)
	{
		int i;
		Class<Inventory> type;
		let player = self.player;
		
		A_PlaySound("cheater", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
		
		if (player.mo == NULL || player.health <= 0)
		{
			return;
		}

		int giveall = ALL_NO;
		if (name ~== "all")
		{
			giveall = ALL_YES;
		}
		else if (name ~== "everything")
		{
			giveall = ALL_YESYES;
		}

		if (name ~== "health")
		{
			if (amount > 0)
			{
				health += amount;
				player.health = health;
			}
			else
			{
				player.health = health = GetMaxHealth(true);
			}
		}

		if (giveall || name ~== "backpack")
		{
			// Select the correct type of backpack based on the game
			type = (class<Inventory>)(gameinfo.backpacktype);
			if (type != NULL)
			{
				GiveInventory(type, 1, true);
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "ammo")
		{
			// Find every unique type of ammo. Give it to the player if
			// he doesn't have it already, and set each to its maximum.
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let ammotype = (class<Ammo>)(AllActorClasses[i]);

				if (ammotype && GetDefaultByType(ammotype).GetParentAmmo() == ammotype)
				{
					let ammoitem = FindInventory(ammotype);
					if (ammoitem == NULL)
					{
						ammoitem = Inventory(Spawn (ammotype));
						ammoitem.AttachToOwner (self);
						ammoitem.Amount = ammoitem.MaxAmount;
					}
					else if (ammoitem.Amount < ammoitem.MaxAmount)
					{
						ammoitem.Amount = ammoitem.MaxAmount;
					}
				}
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "armor")
		{
			if (gameinfo.gametype != GAME_Hexen)
			{
				let armoritem = BasicArmorPickup(Spawn("PostalBrownKevlar"));
				armoritem.SaveAmount = 100*deh.BlueAC;
				armoritem.SavePercent = gameinfo.Armor2Percent > 0 ? gameinfo.Armor2Percent * 100 : 50;
				if (!armoritem.CallTryPickup (self))
				{
					armoritem.Destroy ();
				}
			}
			else
			{
				for (i = 0; i < 4; ++i)
				{
					let armoritem = Inventory(Spawn("HexenArmor"));
					armoritem.health = i;
					armoritem.Amount = 0;
					if (!armoritem.CallTryPickup (self))
					{
						armoritem.Destroy ();
					}
				}
			}

			if (!giveall)
				return;
		}

		if (giveall || name ~== "keys")
		{
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				if (AllActorClasses[i] is "Key")
				{
					let keyitem = GetDefaultByType (AllActorClasses[i]);
					if (keyitem.special1 != 0)
					{
						let item = Inventory(Spawn(AllActorClasses[i]));
						if (!item.CallTryPickup (self))
						{
							item.Destroy ();
						}
					}
				}
			}
			if (!giveall)
				return;
		}

		if (giveall || name ~== "weapons")
		{
			let savedpending = player.PendingWeapon;
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<Weapon>)(AllActorClasses[i]);
				if (type != null && type != "Weapon")
				{
					// Don't give replaced weapons unless the replacement was done by Dehacked.
					let rep = GetReplacement(type);
					if (rep == type || rep is "DehackedPickup")
					{
						// Give the weapon only if it is set in a weapon slot.
						if (player.weapons.LocateWeapon(type))
						{
							readonly<Weapon> def = GetDefaultByType (type);
							if (giveall == ALL_YESYES || !def.bCheatNotWeapon)
							{
								GiveInventory(type, 1, true);
							}
						}
					}
				}
			}
			player.PendingWeapon = savedpending;

			if (!giveall)
				return;
		}

		if (giveall || name ~== "artifacts")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				type = (class<Inventory>)(AllActorClasses[i]);
				if (type!= null)
				{
					let def = GetDefaultByType (type);
					if (def.Icon.isValid() && def.MaxAmount > 1 &&
						!(type is "PuzzleItem") && !(type is "Powerup") && !(type is "Ammo") &&	!(type is "Armor"))
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
						{
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
						}
					}
				}
			}
			if (!giveall)
				return;
		}

		if (giveall || name ~== "puzzlepieces")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<PuzzleItem>)(AllActorClasses[i]);
				if (type != null)
				{
					let def = GetDefaultByType (type);
					if (def.Icon.isValid())
					{
						// Do not give replaced items unless using "give everything"
						if (giveall == ALL_YESYES || GetReplacement(type) == type)
						{
							GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
						}
					}
				}
			}
			if (!giveall)
				return;
		}

		if (giveall)
			return;

		type = name;
		if (type == NULL)
		{
			if (PlayerNumber() == consoleplayer)
				A_Log(String.Format("Unknown item \"%s\"\n", name));
		}
		else
		{
			GiveInventory(type, amount, true);
		}
		return;
	}
	
	// Removes any weapons that normally cannot be equipped by Postal Dude, i.e.: Doom's Chainsaw
	
	virtual void CheckForNonPostalWeapons ()
	{
		class<weapon> PostWeapon = "PostalWeapon";
		
		if (!(Player.ReadyWeapon is PostWeapon))
		{
			Player.PendingWeapon = Weapon(FindInventory("PostHands"));
		}
	}
	
}
