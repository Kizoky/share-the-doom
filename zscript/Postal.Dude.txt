// The HUD can be removed just by taking this inventory from the Player.
// This is only done this way because of ACS
class HUDViewable : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		+Inventory.UNDROPPABLE;
		-Inventory.INVBAR;
	}
}

class PostalDude_Data : Inventory
{
	bool lastground;
	double lastvelz, prevvelz, MoveSpeed;
	
	// GZPostal related variables
	
	bool Urethra, Holster, Kick, Suicide, SpawnedOnce;
	// Health Pipe
	bool PipeSmoked, SavedLevelTimePipe, InitPipeTimeCheck, DoOnce, InitPipeValue, SmokeInhale, SmokeFinished, SmokePain, FirstWarning, SecondWarning;
	double PipeTime, PipeTimeStatic, PipeDuration, InitPipeTime, FixedPipeDuration, InHaleCount;
	
	// Catnip
	bool CatnipInProgress, CatnipTimeSaved, CatnipInhale, CatnipInhaleFinished, CatnipDurationSaved;
	double CatnipTime, CatnipTimeSecond, CatnipTimeContinous, CatnipTimeContinousSecond, CatnipCountdown, SavedCatnipTime;
	
	// Cop
	double CooldownTime;
	bool CooldownTimeDone;
	
	bool KickDone;
	
	Weapon HolsterSave, UrethraSave;
	Weapon HolsterWeapon, UrethraWeapon;
	
	bool RunningStop;
	int RunningStopCooldown;
	
	int isinPainCooldown;
	double isinPainAlpha;
	
	bool P_GodMode, P_NoClip, P_NoTarget, P_Frightening;
	
	bool DudeLineTriggered;
	int TimeBeforeDudeLine, DudeLineCooldown;
	
	int IdlingTime;
	vector3 IdlingPos;
	
	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner (other);
		Urethra = false;
		Holster = false;
		Kick = false;
		MoveSpeed = vel.xy.Length();
		HolsterWeapon = Weapon(FindInventory("PostHands"));
		UrethraWeapon = Weapon(FindInventory("PostUrethra"));
		SpawnedOnce = false;
		if (DoOnce != true)
		{
			PipeSmoked = false;
			InitPipeTimeCheck = false;
			DoOnce = true;
		}
	}

}

class PostalDude : PlayerPawn replaces DoomPlayer
{
	PostalDude_Data PlayerData;
	bool Kick, Map;
	bool isinPain;
	bool isDead, DummyCorpseSpawned;
	bool scndSuicide;
	bool isonFire;
	bool MissileOnce;
	Actor MyAnnoyingFire;
	
	Actor DummyCorpse;
	
	Actor IdlingTarget;
	
	int SuicideAngle;
	
	// Needed for Cop AI
	double PunishPoints;
	bool ResetDoneByCop;
	
	string ChosenTip;
	
	bool InitLine;
	
	bool Suicided;
	
	Actor SuicideCamera;
	
	// This variable shouldn't really matter much being here
	int TimeBeforeNextPainLine;
	
	//Initial function for giving the Data inventory to the player.
	//According to phantombeta if these are stored in the PlayerPawn the information will get lost eventually.
	void DataInit()
	{
		if (!player || player.mo != self)
			return;
			
		if (!PlayerData)
		{
			if (!(PlayerData = PostalDude_Data(FindInventory('PostalDude_Data'))))
			{
				GiveInventory('PostalDude_Data', 1);
				PlayerData = PostalDude_Data(FindInventory('PostalDude_Data'));
			}
		}
	}
	
	//I needed a function to access it within ZScript HUD, probably not needed so I will investigate later
	virtual void PD_Pain()
	{
		if (PlayerData.isinPainCooldown < level.time)
		{
			isinPain = false;
		}
		else
			PlayerData.isinPainAlpha += 0.01;
			
	}
	
	//This function is called by NPCCop when hurt by the player.
	//It makes the Wanted meter wider
	virtual void ResetPunishment()
	{
		PlayerData.CooldownTime = level.time + (35 * 15);
		ResetDoneByCop = true;
	}
	
	//This function triggers killing spree lines.
	//Called by an EventHandler
	void A_TriggerDudeLine()
	{
		if (level.time < PlayerData.DudeLineCooldown)
			return;
		
		int Chance = random[DudeLine](0,100);
		
		if (InitLine == true)
		{
			PlayerData.TimeBeforeDudeLine = level.time + 40;
			PlayerData.DudeLineTriggered = true;
			InitLine = false;
		}
		
		if (PlayerData.DudeLineTriggered == true && level.time > PlayerData.TimeBeforeDudeLine)
		{		
			if (Chance > 50)
			{
				A_StartSound("dudekill", CHAN_VOICE, CHANF_NOSTOP);
				PlayerData.DudeLineCooldown = level.time + 35 * 5;
			}
			PlayerData.DudeLineTriggered = false;
		}
	}
	
	//On Death a random tip message will display.
	//todo: add more tips + try reading the situation via blockthingsiterator
	void GenerateTip()
	{
		int i = random[tip](0,TipList.Size()-1);
		ChosenTip = TipList[i];
	}
	
	// Removes (or atleast tries to) Doom bobbing
	// This includes falling bob
	void DoomDeletus()
	{
		// Disables Doom's falling bob
		player.deltaviewheight = ViewHeight;
		
		// There's a slight delay before completely stopping the Player, just like in Postal 2
		UserCmd cmd = player.cmd;
		if (!(GetPlayerInput(INPUT_FORWARDMOVE)) && !(GetPlayerInput(INPUT_SIDEMOVE)) && !(player.cmd.buttons & BT_JUMP) && player.onground)
		{	
			if (level.time > PlayerData.RunningStopCooldown)
			{
				vel.xy = (0,0);
				PlayerData.RunningStop = false;
			}
		}
		else
		{
			if (PlayerData.RunningStop != true)
			{
				PlayerData.RunningStopCooldown = level.time + 8;
				PlayerData.RunningStop = true;
			}
		}
		
		// Disable bobbing when walking
		// Note: this variable is also used by the Cat's AI to check the Player if it's walking or running
		if (PlayerData)
			PlayerData.MoveSpeed = vel.xy.Length();
			
		if (PlayerData.MoveSpeed < 3 && PlayerData)
			ViewBob = 0;
		else
			ViewBob = default.ViewBob; //might come in handy in the future: GetDefaultsByType (<class>)
	}
	
	// Checks every tick if Player is dead and spawns a dummy version of the Player (also prints a tip)
	// Only reason is because Chasecam2 sets it's angle to match with the Player's angle
	void DeathCheck()
	{
		if (self.Health < 1 && PlayerData.Suicide != true)
		{
			if (DummyCorpseSpawned != true)
			{
				if (DummyCorpseSpawned == true)
					return;
					
				DummyCorpseSpawned = true;
					
				if (DummyCorpse != null)
					return;
				
				// Spawn the corpse with as the variable above, 
				// the second argument will spawn it with the actor's position + replacing it
				class<actor> dummy = "DummyDude";
				DummyCorpse = spawn(dummy, self.pos);
				
				// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
				// but make sure to check it's not null or else GZDoom will crash
				if (DummyCorpse)
				{
					DummyCorpse.angle = SuicideAngle;
					
					let dd = DummyDude(DummyCorpse);
					if (dd)
					{
						dd.MyDude = self;
						dd.CorpseOnly = true;
					}
					if (Suicided == true) dd.SetStateLabel("Corpse");
					else dd.SetStateLabel("Corpse.Head");
					
				}
				
				JumpZ = 0;
				GenerateTip();
			}
			
			//A_Print(ChosenTip);
		}
	}
	
	// Wanted-related checks
	void WantedSystem()
	{
		// 8 is the maximum number which will fill the Badge, going over 8 will draw a nice long red line you don't want
		if (PunishPoints > 8)
			PunishPoints = 8;
			
		// Check if we were naughty, note that the cooldown stuff is in ResetPunishment()
		// Continously decreases wanted meter after a period of time if no Cop saw the Player
		if (level.time > PlayerData.CooldownTime && ResetDoneByCop == true && PlayerData)
		{
			PunishPoints -= 0.01;
			
			if (PunishPoints < 0)
			{
				PlayerData.CooldownTimeDone = false;
				ResetDoneByCop = false;
				PunishPoints = 0;
			}
		}
	}
	
	// Health Pipe
	void HealthPipeTick()
	{
		// Too many if elses?
		if (PlayerData.PipeSmoked == true && PlayerData.Suicide != true && PlayerData)
		{
			//Count to 3 seconds
			if (PlayerData.SmokeInhale != true)
			{
				A_PlaySound("smoke/exhale", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.InHaleCount = level.time + (35 * 3);
				PlayerData.SmokeInhale = true;
			}
			
			//Start the whole counting, if level's time is more than InHaleCount, set Health
			//and start the counting
			if (level.time > PlayerData.InHaleCount && PlayerData.SmokeFinished != true)
			{
				A_PlaySound("dudeline10", CHAN_WEAPON | CHAN_UI, 1.0, false, ATTN_NONE);
				A_SetHealth(125);
				A_TakeInventory("PostalCrackPipe", 1);
				PlayerData.SmokeFinished = true;
			}
			
			if (PlayerData.SmokeFinished == true)
			{
				//Store the current time of the level we are in
				//This won't change if the player decides to go into an another level
				if (PlayerData.InitPipeTimeCheck != true)
				{
					PlayerData.InitPipeTime = level.time;
					PlayerData.InitPipeTimeCheck = true;
				}
				
				// Set the PipeDuration's time to the level we are currently in
				// Again, this will never trigger anymore unless the Pipe Duration exceeds 14k ticks
				if (PlayerData.InitPipeValue != true)
				{
					PlayerData.PipeDuration = level.time - 1;
					PlayerData.InitPipeValue = true;
				}
				
				// Add 14k ticks to InitPipeTime and add it to the PipeTimeStatic variable
				// And just like again what has been said above
				if (PlayerData.SavedLevelTimePipe != true)
				{
					PlayerData.PipeTimeStatic = (PlayerData.InitPipeTime + (35 * 400)); //in Postal 2 the addiction kicks after 400 seconds (that's 14000 ticks)
					PlayerData.SavedLevelTimePipe = true;
				}
				
				// If PipeDuration exceeds more than +14000 ticks, do this
				if (PlayerData.PipeDuration > PlayerData.PipeTimeStatic && PlayerData.FirstWarning != true)
				{
					A_PlaySound("player/healthpipewarning", CHAN_WEAPON | CHAN_UI, 1.0, false, ATTN_NONE);
					PlayerData.FirstWarning = true;
				}
				
				//Let's assume the second warning kicks after 60 seconds
				if (PlayerData.PipeDuration > (PlayerData.PipeTimeStatic + (35 * 60)) && PlayerData.SecondWarning != true)
				{
					A_PlaySound("player/healthpipewarning", CHAN_WEAPON | CHAN_UI, 1.0, false, ATTN_NONE);
					PlayerData.SecondWarning = true;
				}
				
				//And finally the hurt
				if (PlayerData.PipeDuration > (PlayerData.PipeTimeStatic + (35 * 120)))
				{
					PlayerData.SmokePain = true;
					Console.Printf("You are starting to feel worse... Take some Health pipe!");
					A_PlaySound("player/healthpipehurt", CHAN_WEAPON | CHAN_UI, 1.0, false, ATTN_NONE);
					PlayerData.PipeSmoked = false;
					PlayerData.SavedLevelTimePipe = false;
					PlayerData.InitPipeValue = false;
					PlayerData.InitPipeTimeCheck = false;
					PlayerData.SmokeInhale = false;
					PlayerData.SmokeFinished = false;
					PlayerData.PipeDuration = 0;
					PlayerData.FirstWarning = false;
					PlayerData.SecondWarning = false;
					//25% of Health always
					A_DamageSelf((Player.Health / 100) * 25);
				}
				
				// Add 1 every ticks (35 ticks == 1 second)
				PlayerData.PipeDuration += 1;
				
				//Console.Printf("Health Pipe Duration: %d", PipeDuration);
				//Console.Printf("Required time for First warning: %d (400 seconds)",PipeTimeStatic);
				//Console.Printf("Second warning: %d (60 seconds)",PipeTimeStatic + (35 * 10));
				//Console.Printf("Health pipe my ass: %d (60 seconds)",PipeTimeStatic + (35 * 20));
			}
		}
	}
	
	// Catnip
	void CatnipTick()
	{
		// I guess I don't have to say this is ugly as hell.
		if (PlayerData.CatnipInProgress == true && PlayerData)
		{
			if (PlayerData.CatnipInhale != true)
			{
				A_PlaySound("smoke/exhale", CHAN_WEAPON | CHAN_UI, 2.0, false, ATTN_NONE);
				PlayerData.CatnipCountdown = level.time + (35 * 3);
				//CatnipTimeContinousSecond = -5;
				PlayerData.CatnipInhale = true;		
			}
			
			if (level.time > PlayerData.CatnipCountdown && PlayerData.CatnipTimeSaved != true)
			{
				PlayerData.CatnipTime = level.time + 5;
				PlayerData.CatnipTimeSecond = level.time + 3;
				A_GiveInventory("CatnipSphere", 1);
				A_GiveInventory("SMPowerTimeFreezerSound", 1);
				A_PlaySound("dudecatnip", CHAN_WEAPON | CHAN_UI, 1.0, false, ATTN_NONE);
				PlayerData.CatnipTimeSaved = true;
				PlayerData.CatnipInhaleFinished = true;
				PlayerData.CatnipTimeContinous = level.time;
				PlayerData.CatnipTimeContinousSecond = level.time;
				A_TakeInventory("PostalCatnip", 1);
			}
			
			if (PlayerData.CatnipInHaleFinished == true)
			{
				PlayerData.CatnipTimeContinous += 1;
				PlayerData.CatnipTimeContinousSecond += 1;
				
				if (PlayerData.CatnipTimeContinous > PlayerData.CatnipTime)
				{
					A_GiveInventory("SMPowerTimeFreezerSound", 1);
					PlayerData.CatnipTime = level.time + 3;
				}
				
				if (PlayerData.CatnipTimeContinousSecond > PlayerData.CatnipTimeSecond)
				{
					A_TakeInventory("SMPowerTimeFreezerSound", 1);
					PlayerData.CatnipTimeSecond = level.time + 7;
				}
				
				if (PlayerData.CatnipDurationSaved != true)
				{
					PlayerData.SavedCatnipTime = (level.time + (35 * 45));
					PlayerData.CatnipDurationSaved = true;
				}
				
				if (PlayerData.CatnipTimeContinous > PlayerData.SavedCatnipTime)
				{
					A_TakeInventory("SMPowerTimeFreezerSound", 1);
					A_TakeInventory("CatnipPower", 1);
					A_TakeInventory("CatnipSphere", 1);
					PlayerData.CatnipInProgress = false;
					PlayerData.CatnipDurationSaved = false;
					PlayerData.CatnipTimeSaved = false;
					PlayerData.CatnipInhaleFinished = false;
					PlayerData.CatnipInhale = false;
				}
			}
			
				//Console.Printf("CatnipTime: %d", PlayerData.CatnipTime);
				//Console.Printf("CatnipTimeContinous: %d", PlayerData.CatnipTimeContinous);
				//Console.Printf("CatnipTimeSecond: %d", PlayerData.CatnipTimeSecond);
				//Console.Printf("CatnipTimeContinousSecond: %d", PlayerData.CatnipTimeContinousSecond);
		}
	}
	
	// Suicide
	void SuicideTick()
	{
		if (PlayerData.Suicide == True && PlayerData)
		{
			if (PlayerData.SpawnedOnce == false)
			{
				//Console.MidPrint ("INDEXFONT_DOOM","Press fire to end it all.");
				A_GiveInventory("CameraRunner", 1);
				Speed = 0;
				JumpZ = 0;
				A_SuicideDude();
					
				SetStateLabel("Invis");
				A_TakeInventory("HUDViewable",1);
				bDONTTHRUST = true;
				//A_Print("Press fire to end your pitiful life.");
				PlayerData.SpawnedOnce = true;
			}
			Player.ReadyWeapon = PlayerData.HolsterWeapon;
		}
	}
	
	// Idling
	// This is currently broken
	void IdlingTick()
	{
		if (level.time > PlayerData.IdlingTime && PlayerData && level.mapname != "TITLEMAP")
		{
			PlayerData.IdlingTime = level.time + 2100;
				
			if (PlayerData.IdlingPos == pos)
			{
				int randomm = random[idle](1,1);
				
				switch(randomm)
				{
					default:
						Console.Printf("An error has occured: Idling states randomization");
						break;
						
					case 1:
						SetStateLabel("Idling.Seeing");
						break;
				}		
				return;
			}		
			PlayerData.IdlingPos = pos;
		}
	}
	
	void FootstepTick()
	{
		// Footstep code from Marisa's Doom Tournament
		// edited a little bit to only make footsteps when running
		if (PlayerData.MoveSpeed > 3 && PlayerData)
		{
			bool forcefootstep = false;
			double ang = level.time/(20*8.4/35.)*360.;
			
			if (player.health != 0)
			{
				if ( player.onground && !bNoGravity && !PlayerData.lastground && (waterlevel < 3))
				{
					player.jumptics = 0;
					if ( PlayerData.lastvelz < -20 )
					{
						double vol = clamp((-PlayerData.lastvelz-8)*0.05,0.01,1.0);
						if ( ((waterlevel > 0) || GetFloorTerrain().IsLiquid) && !bOnMobj )
							A_PlaySound("",CHAN_AUTO,vol);
						else
							A_PlaySound("footstep",CHAN_AUTO,vol);
					}
					else forcefootstep = true;
				}
				
				if ( forcefootstep || ((abs(sin(ang)) >= 1.0) && player.onground && PlayerData.lastground &&
				(player.jumptics == 0) && (player.cmd.forwardmove || player.cmd.sidemove) && (waterlevel < 3)) )
				{
					double vol = abs(vel.xy.length())*0.20;
					if ( forcefootstep ) 
						vol = clamp(-PlayerData.lastvelz*0.10,0.01,1.0);
					if ( (waterlevel > 0) || GetFloorTerrain().IsLiquid && !bOnMobj ) 
						A_PlaySound("",CHAN_6,vol);
					else A_PlaySound("footstep",CHAN_6,vol);
				}
			}
			
			PlayerData.lastground = player.onground;
			PlayerData.lastvelz = PlayerData.prevvelz;
			PlayerData.prevvelz = vel.z;
		}
	}
	
	// Handles pain lines when hurt
	void A_DudePain()
	{
		int LongChance = random[pain](0,100);
		
		if (level.time > TimeBeforeNextPainLine)
		{
			if (LongChance < 85)
				TimeBeforeNextPainLine = level.time + 32;
			else
				TimeBeforeNextPainLine = level.time + 35 * 3;
		}
		else
			return;
		
		if (LongChance > 85)
		{
			A_StartSound("dudelonghurt", CHAN_VOICE, CHANF_NOSTOP);
			return;
		}
		
		A_StartSound("dudehurt", CHAN_VOICE, CHANF_NOSTOP);
			
		//A_PlaySound("hitflesh",6);
	}
	
	// Spawns a Dummy for suiciding
	void A_SuicideDude(class<actor> dummy = "DummyDude")
	{
		Actor DummyDude;
		// Spawn the corpse with as the variable above, 
		// the second argument will spawn it with the actor's position + replacing it
		if (PlayerData.Suicide == true && PlayerData)
			DummyDude = spawn(dummy, self.pos, ALLOW_REPLACE);
		
		// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
		// but make sure to check it's not null or else GZDoom will crash
		if (DummyDude)
		{
			DummyDude.angle = self.angle;
			let dd = DummyDude(DummyDude);
			if (dd)
				dd.MyDude = self;
		}	
	}
	
	// Note: This needs a rework because it's ugly and broken
	// "Alerts" nearby NPCs if the Player is firing with a melee weapon or a Firearm
	// This obviously has some flaws that needs some fixes
	void A_ShriekNearbyNPCs()
	{
		if (Player.ReadyWeapon == Weapon(FindInventory("PostHands")) || Player.ReadyWeapon == Weapon(FindInventory("PostUrethra")) || Player.ReadyWeapon == Weapon(FindInventory("PostClipboard")))
			return;
		
		BlockThingsIterator it;
		double fov = 90;
		bool isMeleeAttack;
		
		//melee weapons should have a shorter distance?
		
		if (Player.ReadyWeapon == Weapon(FindInventory("PostBaton")) ||
			Player.ReadyWeapon == Weapon(FindInventory("PostMachete")) ||
			Player.ReadyWeapon == Weapon(FindInventory("PostScythe")) ||
			Player.ReadyWeapon == Weapon(FindInventory("PostShovel")) ||
			Player.ReadyWeapon == Weapon(FindInventory("PostSledge")) ||
			Player.ReadyWeapon == Weapon(FindInventory("PostTazer")))
			{
				it = BlockThingsIterator.Create (self, 350);
				isMeleeAttack = true;
			}
			else
				it = BlockThingsIterator.Create (self, 600); // The number here is (possibly roughly) the maximum distance they can see
				
		while (it.Next ()) {
			let next = it.Thing;
			
			if (next is 'NPCCore' && !(next.bKILLED))
			{
				if (isMeleeAttack == true && (AbsAngle (AngleTo (next), next.angle) > (fov / 2.)))
				{
					//Console.Printf("Within fov!");
					let p = NPCCore(next);
					if (p.isBusy != true && p.isAfterTarget == false && p)
					{
						p.isBusy = true;
						p.MyTarget = self;
						p.vel.xy = (0,0);
						//todo: Give them the sliding to left or right anim state (probs it's the same with weapons just from very far away)
						p.SetStateLabel("StaringWeapon");
					}
					break;
				}
				
				if (isMeleeAttack != true)
				{
					let p = NPCCore(next);
					if (p.isBusy != true && p.isAfterTarget == false && p)
					{
						p.isBusy = true;
						p.MyTarget = self;
						p.vel.xy = (0,0);
						p.SetStateLabel("StaringWeapon");
					}
				}
			}
		}
    }
	
	// Grabs a random target to stare at when AFK for a long time.
	void A_FindIdleTargeting()
	{
		BlockThingsIterator it = BlockThingsIterator.Create (self, 2000); // The number here is (possibly roughly) the maximum distance they can see
		
		while (it.Next ()) {
				let next = it.Thing;
				
				if (next is 'NPCCore' && next)
					IdlingTarget = next;
			}
    }
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		DataInit();
			
		cvar developercvar = cvar.findcvar('postal_developer');
		bool developer = (developercvar != null && developercvar.GetBool ());
		
		if (developer && !multiplayer)
		{
			Speed = 12;
			Health = 666;
			JumpZ = 20;
		}
		
		int cash = 11 + random[cash](10,25);
		A_GiveInventory("PostalCash", cash);
		
		int ammo = 5 + random[clip](5,15);
		A_GiveInventory("Clip", ammo);
		
	}
	
	override void Tick()
	{
		Super.Tick();
		if ( !player || (player.mo != self) ) return;
		
		CheatDetector();
		PD_Pain();
		A_TriggerDudeLine();
		CheckForNonPostalWeapons();
		DoomDeletus();
		DeathCheck();
		WantedSystem();
		HealthPipeTick();
		CatnipTick();
		SuicideTick();
		IdlingTick();
		FootstepTick();
		
		// Kicking
		if (Kick == true)
			A_GiveInventory("PostKick", 1);
			
		// Zombie's Autoaim disabler
		
		if (player.readyWeapon && !player.readyWeapon.default.bNOAUTOAIM)
		{
			// Disable auto-aim when the player is looking at an enemy.
			// This enables the player to pull off headshots even when
			// auto-aim is enabled.
			FLineTraceData data;

			if(LineTrace(angle, 0x7FFFFFFF, pitch, data: data))
				player.readyWeapon.bNOAUTOAIM = data.hitActor != null;
			else
				player.readyWeapon.bNOAUTOAIM = false;
		}
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (PlayerData == null) return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		
		PlayerData.isinPainCooldown = level.time + 35;
		PlayerData.isinPainAlpha = 0;
		isinPain = true;
		
		if (!bKILLED)
		{
			if (PlayerData.Suicide == true)
			{
				A_DudePain();
				SetStateLabel("Invis");
				return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
			}
			
			if (PlayerData.SmokePain == true)
				PlayerData.SmokePain = false;
			else
				A_DudePain();
			
			return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
			
		}
		
		return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	
	Default
	{
		Player.DisplayName "Postal Dude";
		//Note: These 3 weapons are essential, in a new game Postal Dude will always have these
		//Removing these weapons (in a level or anything) might crash the game 
		Player.StartItem "PostHands";
		Player.StartItem "PostUrethra";
		Player.StartItem "PostMatchbox";
		
		//Player.StartItem "PostShovel";
		//Player.StartItem "PostClipboard";
		//Player.StartItem "PostMachete";
		//Player.StartItem "PostSledge";
		//Player.StartItem "PostPistol";
		//Player.StartItem "PostShotgun";
		//Player.StartItem "PostM16";
		//Player.StartItem "PostRLauncher";
		//Player.StartItem "PostRifle";
		//Player.StartItem "PostScythe";
		//Player.StartItem "PostGascan";
		//Player.StartItem "PostBaton";
		Player.StartItem "PostCowhead";
		//Player.StartItem "PostGrenade";
		//Player.StartItem "PostMolotov";
		//Player.StartItem "PostNapalmLauncher";
		//Player.StartItem "PostScissors";
		//Player.StartItem "PostTazer";
		//Player.StartItem "PostWMD";
		//Player.StartItem "PostDebug";
		Player.StartItem "HUDViewable", 1;
		Player.StartItem "Piss", 20;
		Player.Soundclass "PostalDude";
		Player.WeaponSlot 0, "PostClipboard", "PostDebug";
		Player.WeaponSlot 1, "PostMachete", "PostSledge", "PostShovel", "PostScythe", "PostBaton", "PostMatchbox", "PostTazer";
		Player.WeaponSlot 2, "PostPistol";
		Player.WeaponSlot 3, "PostShotgun", "";
		Player.WeaponSlot 4, "PostM16";
		Player.WeaponSlot 5, "PostRLauncher", "PostGascan", "PostGrenade", "PostMolotov", "PostWMD";
		Player.WeaponSlot 6, "PostRifle", "PostScissors";
		Player.WeaponSlot 7, "PostCowhead", "PostNapalmLauncher";
		Player.ViewBob .12; //.20; // Default for Doom is 1.0
		Player.ViewHeight 59; //Default for Doom is 41.0
		Player.ForwardMove 0.15, 0.48; //(walk, run)
		Player.SideMove 0.30, 0.42; //(walk, run)
		Player.JumpZ 9.2; // Default 8 Don't touch it, everytime Dude jumps it would trigger OOF for some reason
		Player.GruntSpeed 1000;
		Player.DamageScreenColor "red",0;
		Player.AttackZOffset 28;
		+SPECIAL
	}
	States
	{
	Spawn:
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		Loop;
	See:
		DUDW A 0; //<--- This frame is needed for fixing that weird twitching, remove it yourself to test it
		XXXX ABCDEFGHIJKLMNOPQ 2
		{
			if (PlayerData == null) return;
			
			if (PlayerData.MoveSpeed == 0)
				SetStateLabel("Spawn");
			else
				if (PlayerData.MoveSpeed < 1.16)
					SetStateLabel("Walking");
		}
		XXXX A 0; //<--- This frame is needed for fixing that weird twitching, remove it yourself to test it
		Loop;
	Walking:
		DUDW ABCDEFGHIJKLMNOPQR 2;
		Goto See;
	Missile:
		TNT1 A 0
		{
			if (PlayerData)
			{
				if (PlayerData.Suicide == true)
					MissileOnce = true;
				
				if (PlayerData.Suicide == true)
					SetStateLabel("Invis");
			}
			A_ShriekNearbyNPCs();
		}
		DUDF A 12;
		Goto Spawn;
	Melee:
	    TNT1 A 0
		{
			if (PlayerData == null) return;
			
			if (PlayerData.Suicide == true)
				SetStateLabel("Invis");
		}
		DUDE A 6 BRIGHT;
		Goto Missile;
	Idling.Seeing:
		TNT1 A 0 A_FindIdleTargeting();
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 2
		{
			if (IdlingTarget != null)
				Angle = AngleTo(IdlingTarget);
			
			// Checks if the Player is pressing any buttons
			if (player.cmd.buttons)
				SetStateLabel("Spawn");
			
		}
		TNT1 A 0
		{
			int randomm = random[see](1,50);
			
			//if (randomm > 47)
			//	A_PlaySound("dudeline49", 1);
				
			if (randomm > 48)
				A_PlaySound("dudeline50", 0);
		
		}
		Loop;
	Pain:
		TNT1 A 0
		{
			if (PlayerData == null) return;
			
			if (PlayerData.Suicide == true)
				SetStateLabel("Invis");
		}
		DUDE A 4;
		DUDE A 4;
		Goto Spawn;
	Death:
		TNT1 A 0 A_PlayerScream;
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		TNT1 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	Invis:
		TNT1 A 2;
		Loop;
	XDeath:
		TNT1 A 0 A_PlayerScream;
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		TNT1 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	XDeath1:
		TNT1 A 0 A_PlayerScream;
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		TNT1 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	AltSkinDeath:
		TNT1 A 0 A_PlayerScream;
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		TNT1 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	AltSkinXDeath:
		TNT1 A 0 A_PlayerScream;
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		TNT1 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	}
}

class DummyDude2 : DummyDude
{
	override void PostBeginPlay()
	{
		SetStateLabel("Corpse");
	}

}

class DummyDude : Actor
{
	actor MyDude;
	bool Done, CorpseOnly, Multiplayer;
	
	override void Tick()
	{
		Super.Tick();
		
		if (Multiplayer == true)
		{
			if (MyDude != null) MyDude = null;
			
			return;
		}
		
		if (MyDude)
		{
			//deatach from the Player if it's multiplayer
			if (Multiplayer != true)
				SetOrigin(MyDude.pos+(0,0,0), TRUE);
				
			let p = PostalDude(MyDude);
			if (Done != true)
			{
				if (p && CorpseOnly != true)
				{
					if (p.MissileOnce == true && p.PlayerData)
					{
						SetStateLabel("Suicide");
						Done = true;
					}
					
					if (MyDude.bKILLED && p.MissileOnce != true)
						Destroy();
					
				}
			}
			
			if (MyDude.bKILLED && MyDude)
				SetOrigin(MyDude.pos+(0,0,0), TRUE);
		}
	}

	Default
	{
		Health 50;
		Radius 1;
		Height 1;
		-SOLID
		Obituary "%k did not regret anything, said to the world.";
	}
	States
	{
	Spawn:
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		Loop;
	Suicide:
		SUIC A 0 A_PlaySound("dudeline27",6);
		SUIC ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		SUI2 ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		SUI3 ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		SUI4 ABCDEF 2;
		DUDD A 0
		{
			let p = PostalDude(MyDude);
			if (p)
			{
				p.Suicided = true;
				p.A_Die();
			}
			
			A_playSound("weapons/rocklx",6);
			A_Explode(200, 256, XF_NOTMISSILE);
			//let p = PostalDude(MyDude);
			//p.MissileOnce = false;
		}
		MISL BCD 7 Bright Offset(45,45);
		Stop;
	Corpse:
		DUDD A 0 A_PlaySound("misc/gibbed",0);
		DUDD A 0 A_SpawnItemEx("Postal_HeadExplode", 0, 0, FRandom(54.0, 56.0));
		DUDD A 0 A_SpawnItemEx("Postal_HeadExplode", 0, 0, FRandom(54.0, 56.0));
		//Spawn blood particle too to make it feel like the head is crushed
		DUDD A 0 A_SpawnItemEx("Postal_Blood", 0, 0, FRandom(54.0, 56.0));
		DUDD A 0 A_SpawnItemEx("Postal_Blood", 0, 0, FRandom(54.0, 56.0));
		
		//Spawn spinning Skull and brain chunks that are slightly bouncing off from the floors, walls, etc..
		DUDD A 0
		{
			int i = 0;
			while (i < 8) {
				A_SpawnItemEx("Postal_Skullchunk", 0, 0, FRandom(54.0, 56.0), FRandom(0.1, 2.0) * RandomPick(-1, 1), FRandom(0.1, 2.0) * RandomPick(-1, 1), FRandom(0.0, 2.0), 0, SXF_TRANSFERTRANSLATION | SXF_ABSOLUTEPOSITION | SXF_ABSOLUTEANGLE | SXF_ABSOLUTEVELOCITY, 64);
				A_SpawnItemEx("Postal_Brainchunk", FRandom(0.5,1.2), FRandom(0.5,1.2), FRandom(52.0, 55.0), FRandom(0.1, 2.0) * RandomPick(-1, 1), FRandom(0.1, 2.0) * RandomPick(-1, 1), FRandom(0.0, 2.0), 0, SXF_TRANSFERTRANSLATION | SXF_ABSOLUTEPOSITION | SXF_ABSOLUTEANGLE | SXF_ABSOLUTEVELOCITY, 64);
				i++;
			}
		}
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	Corpse.Head:
		TNT1 A 0
		{
			if (MyDude)
				angle = MyDude.angle;
		}
		HEAD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		HEA2 ABCDEFGHIJKLMNOP 2;
		HEA2 P -1;
		Stop;
	Disappear:
		TNT1 A 0;
		Stop;
	}
}