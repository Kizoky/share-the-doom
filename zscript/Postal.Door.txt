// The Doom engine is limited, and according to Graf changing the width of certain actors won't be possible like ever
// This is some sort of "hack" to make the Player feel they are actually interacting with a door and can't pass through it

class PostalDoor_Extender : Actor
{
	Actor AttachedToDoor, AttachedToDoor2;
	int AngleBefore;
	
	int TimeBeforeWarning;
	bool WarningSent;
	
	bool user_middle, SearchFinished;
	
	action void A_SearchForDoor()
	{
		if (invoker.SearchFinished == true) return;
		
		BlockThingsIterator it = BlockThingsIterator.Create (self, 50);
		double fov = 20;
		
		while (it.Next ()) {
			let next = it.Thing;
			if (!next) return;
			
			if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
			{
				continue;
			}
			
			if (invoker.AttachedToDoor == null)
			{
				if (next is 'PostalDoor' && next.pos.z == self.pos.z)
				{
					invoker.AttachedToDoor = next;
					
					if (invoker.user_middle) angle = angle + 180;
					
					if (invoker.user_middle != true)
					{
						invoker.SearchFinished = true;
						return;
					}
				}
			}
			
			if (invoker.user_middle == true)
			{
				if (invoker.AttachedToDoor2 == null)
				{
					if (next != invoker.AttachedToDoor && next is 'PostalDoor' && next.pos.z == self.pos.z)
					{
						invoker.AttachedToDoor2 = next;
						invoker.SearchFinished = true;
					}
				}
			}
		}
    }
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		let door = PostalDoor(AttachedToDoor);
		let door2 = PostalDoor(AttachedToDoor2);
		
		if (door != null)
		{
			/*
			if (abs (DeltaAngle (door.AngleBefore, source.angle)) >= 90)
			{
				Console.Printf("Front: %d", source.angle);
			} else Console.Printf("Back: %d", source.angle);
			*/
			
			if (door.user_locked == true)
			{
				A_PlaySound("door/kick", 0);
				return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
			}
			
			if (door.DoorClosed == false) return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
			
			door.HitOnce = true;
			door.DoorCloseTime = level.time + (35 * 5);
			if (door2 != null)
			{
				door2.HitOnce = true;
				door2.DoorCloseTime = level.time + (35 * 5);
			}
			
			A_PlaySound("door/kick", 0);
			
			// A simple check to detect if Door was hit in front or back
			if (abs (DeltaAngle (door.AngleBefore, source.angle)) >= 90)
			{
				door.FrontBack = false;
				door.RotationSpeed = 16;
				door.SetStateLabel("Open");
				
				if (door2 != null)
				{
					door2.FrontBack = true;
					door2.RotationSpeed = 16;
					door2.SetStateLabel("Open");
				}
				
				return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
			} 
			else 
			{
				door.FrontBack = true;
				door.RotationSpeed = 16;
				door.SetStateLabel("Open");
				
				if (door2 != null)
				{
					door2.FrontBack = false;
					door2.RotationSpeed = 16;
					door2.SetStateLabel("Open");
				}
				
				return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
			}
		}
		
		return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	
	override void Touch(Actor toucher)
	{
		if (toucher)
		{
			let door = PostalDoor(AttachedToDoor);
			let door2 = PostalDoor(AttachedToDoor2);
			let NPC = NPCCore(toucher);
			
			//if (NPC) NPC.SetStateLabel("Standing");
			
			if (door != null)
			{
				if (door.user_locked == true) return;
				
				if (door.DoorClosed == false) return;
				
				door.HitOnce = true;
				door.DoorCloseTime = level.time + (35 * 5);
				
				if (door2 != null)
				{
					door2.HitOnce = true;
					door2.DoorCloseTime = level.time + (35 * 5);
				}
				
				A_PlaySound("door/open", 0);
				
				// A simple check to detect if Door was hit in front or back
				if (abs (DeltaAngle (door.AngleBefore, toucher.angle)) >= 90)
				{
					door.FrontBack = false;
					door.RotationSpeed = 8;
					door.SetStateLabel("Open");
					
					if (door2 != null)
					{
						door2.FrontBack = true;
						door2.RotationSpeed = 8;
						door2.SetStateLabel("Open");
					
					}
					
					return;
				} 
				else 
				{
					door.FrontBack = true;
					door.RotationSpeed = 8;
					door.SetStateLabel("Open");
					
					if (door2 != null)
					{
						door2.FrontBack = false;
						door2.RotationSpeed = 8;
						door2.SetStateLabel("Open");
					}
					return;
				}
			}
		}
	}
	
	vector3 OriginalPos;
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		OriginalPos = pos;
		
		TimeBeforeWarning = level.time + 35 * 3;
	}
	
	override void Tick()
	{
		Super.Tick();
		SetOrigin(OriginalPos, TRUE);
		
		let door = PostalDoor(AttachedToDoor);
		if (door != null)
		{
			if (door.DoorClosed == false)
			{
				bNOCLIP = true; 
				bSHOOTABLE = false;
			} else { bNOCLIP = false; bSHOOTABLE = true; }
		}
		
		if (level.time > TimeBeforeWarning && !door && !WarningSent)
		{
			Console.Printf("Warning: Extender has no attached Door at (warp %d %d %d)!!!", pos.x, pos.y, pos.z);
			Console.Printf("Is the Extender facing it's Door correctly? & has same Z position as the Door?");
			Console.Printf("");
			WarningSent = true;
		}
		
	}
	
	Default
	{
		//$Category Gameplay
		//$Title "Door Extender"
		//$Sprite ZDORA0
		Radius 7;
		Height 85;
		+SHOOTABLE
		+ROLLSPRITE
		+ABSMASKPITCH
		+MOVEWITHSECTOR
		+NOTARGET
		MONSTER;
		+FRIENDLY
		+INTERPOLATEANGLES
		+NOBLOOD
		+SPECIAL
		PainChance 0;
		BloodType "null";
		Health 99999999;
	}
	States
	{
	Spawn:
		TNT1 A 10 A_SearchForDoor();
		Loop;
	}
}

class PostalDoor : Actor
{
	int AngleBefore;
	int DoorCloseTime;
	bool DoorClosed;
	bool HitOnce;
	bool FrontBack;
	
	float RotationSpeed;
	
	
	//GZDB Flags
	
	bool user_locked, user_destroyable;
	bool user_openonce, user_onlyNPC;
	bool user_onlyPlayer;
	
	int user_lockAfter, user_openAfter;
	
	bool user_noNPCdamage, user_ignoreDoomDamage;
	
	string user_key;
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		/*
		if (abs (DeltaAngle (AngleBefore, source.angle)) >= 90)
		{
			Console.Printf("Front: %d", source.angle);
		} else Console.Printf("Back: %d", source.angle);
		*/
		
		if (user_locked == true) return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		
		//Check to prevent spamming that would break the door
		if (DoorClosed == false) return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		
		HitOnce = true;
		DoorCloseTime = level.time + (35 * 5);
		A_PlaySound("door/kick", 0);
		
		// A simple check to detect if Door was hit in front or back
		
		if (source == null) return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		
		if (abs (DeltaAngle (AngleBefore, source.angle)) >= 90)
		{
			FrontBack = false;
			SetStateLabel("Open");
			return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		} 
		else 
		{
			FrontBack = true;
			SetStateLabel("Open");
			return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		}
		return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	
	virtual void A_OpenDoor()
	{
		DoorClosed = false;
		
		// If hit from front
		if (FrontBack == true)
		{
			//Console.Printf("Hitting front");
			if (abs (deltaangle (angle, AngleBefore-90)) < 10)
			{
				angle = AngleBefore-90;
				SetStateLabel("Spawn");
				return;
			}
			
			if (((AngleBefore-90) - angle + 360) % 360 < 180)
			{	
				angle = angle+RotationSpeed;
			}
			else angle = angle-RotationSpeed;
		}
		
		// If hit from back
		if (FrontBack == false)
		{
			//Console.Printf("Hitting back");
			if (abs (deltaangle (angle, AngleBefore+90)) < 10)
			{
				angle = AngleBefore+90;
				SetStateLabel("Spawn");
				return;
			}
			
			if (((AngleBefore+90) - angle + 360) % 360 < 180)
			{	
				angle = angle+RotationSpeed;
			}
			else angle = angle-RotationSpeed;
		}
		
	}
	
	virtual void A_CloseDoor()
	{
		RotationSpeed = 16;
		
		if (abs (deltaangle (angle, AngleBefore)) < 10)
		{
			DoorClosed = true;
			angle = AngleBefore;
			A_PlaySound("door/close", 0);
			SetStateLabel("Spawn");
			return;
		}
		
		if (((AngleBefore) - angle + 360) % 360 < 180)
		{	
			angle = angle+RotationSpeed;
		}
		else angle = angle-RotationSpeed;
		
	}
	
	vector3 OriginalPos;
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		AngleBefore = self.angle;
		DoorClosed = true;
		OriginalPos = pos;
		RotationSpeed = 16;
	}
	
	override void Tick()
	{
		Super.Tick();
		SetOrigin(OriginalPos, TRUE);
		
	}
	
	Default
	{
		//$Category Gameplay
		//$Title "Door"
		//$Color 5
		Radius 5;
		Height 85;
		+SHOOTABLE
		+ROLLSPRITE
		+ABSMASKPITCH
		+MOVEWITHSECTOR
		+NOTARGET
		MONSTER;
		+FRIENDLY
		+INTERPOLATEANGLES
		+NOBLOOD
		PainChance 0;
		Health 99999999;
	}
	States
	{
	Spawn:
		PROP A 10
		{
			if (level.time > DoorCloseTime && DoorClosed == false && HitOnce == true)
			{
				SetStateLabel("Close");
			}
		}
		Loop;
	Open:
		PROP A 2 A_OpenDoor();
		Loop;
	Close:
		PROP A 2 A_CloseDoor();
		Loop;
	}
}


class PostalDoor2 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Door Slatted"
		//$Color 5
	}
}

class PostalDoor3 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Door Hagendaas"
		//$Color 5
	}
}

class PostalDoor4 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Door Nice (Blue Window)"
		//$Color 5
	}
}


class PostalDoor5 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Cheap Red Door"
		//$Color 5
	}
}


class PostalDoor6 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Elegant Wood Door"
		//$Color 5
	}
}

class PostalDoor7 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Ratty Door"
		//$Color 5
	}
}


class PostalDoor8 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Grey Metal Door"
		//$Color 5
	}
}


class PostalDoor9 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Green Door Woodie"
		//$Color 5
	}
}


class PostalDoor10 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Generic Office Door"
		//$Color 5
	}
}


class PostalDoor11 : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Shitty Wood Door"
		//$Color 5
	}
}

class PostalDoorJesus : PostalDoor
{
	Default
	{
		//$Category Gameplay
		//$Title "Church Door"
		//$Color 5
	}
}