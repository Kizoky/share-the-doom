class PostalActor : Actor 
{
	bool STD_NeverTarget, STD_NoKillLine;
	
	property NeverTarget : STD_NeverTarget;
	property NoKillLine : STD_NoKillLine;
	
	// shitty port of A_DoChase to ZScript
	
	const CLASS_BOSS_STRAFE_RANGE = 64*10;
	void A_PostalDoChase (bool fastchase, State meleestate, State missilestate, bool playActive, bool nightmareFast, bool dontMove, int flags)
	{
		if (bInConversation)
			return;
			
		if (bInChase)
			return;
			
		bInChase = true;
		
		bool isFast = bALWAYSFAST ? true : false;
		
		// [RH] Andy Baker's stealth monsters
		if (bStealth)
			visdir = -1;
			
		if (reactiontime)
			reactiontime--;
			
		// [RH] Don't chase invisible targets
		if (target != null &&
			target.bINVISIBLE &&
			target != goal)
		{
			target = null;
		}
		
		// modify target threshold
		if (target != null || target.Health <= 0)
			threshold = 0;
		else
			threshold--;
		
		// Monsters move faster in nightmare mode
		if (nightmareFast && G_SkillPropertyInt (SKILLP_FastMonsters))
		{
			if (tics > 3)
			{
				tics -= tics / 2;
				if (tics < 3)
				{
					tics = 3;
				}
			}
		}
		
		// turn towards movement direction if not there yet
		if (strafecount)
		{
			A_FaceTarget();
		}
		else if (!(flags & CHF_NODIRECTIONTURN && moveDir < 8))
		{
			angle = floor(angle / 45) * 45.;
			double delta = deltaangle(angle,(moveDir * 45));
			if (delta < 0)
			{
				angle -= 45;
			}
			else if (delta > 0)
			{
				angle += 45;
			}
		}
		
		/*
		// [RH] If the target is dead or a friend (and not a goal), stop chasing it.
		if (target && target != goal && (target.health <= 0 || isFriend (target)))
			target = null;
		*/
		
		// [RH] Friendly monsters will consider chasing whoever hurts a player if they
		// don't already have a target.
		if (bFRIENDLY && target == null)
		{
			PlayerInfo player;
			
			if (FriendPlayer != 0)
			{
				player = Players[FriendPlayer - 1];
			}
			else
			{
				int i;
				if (!multiplayer)
				{
					i = 0;
				}
				else for (i = random[newchasedirr](0,255) & (MAXPLAYERS-1); !PlayerInGame[i]; i = (i+1) & (MAXPLAYERS-1))
				{
				}
				
				player = Players[i];
			}
			if (player.attacker && player.attacker.health > 0 && player.attacker.bSHOOTABLE && random[newchasedirr](0,255) < 80)
			{
				if (!player.attacker.bFRIENDLY ||
					deathmatch && FriendPlayer != 0 && player.attacker.FriendPlayer != 0 &&
					FriendPlayer != player.attacker.FriendPlayer)
				{
					target = player.attacker;
				}
			}
		}
		
		// Look for a new target
		if ((!target || !target.bSHOOTABLE))
		{
			let a = NPCCore(self);
			if (a && a.Hostility ~== "Pussy" && a.hasSeenCorpse) return;
			
			if (target != null && target.bNONSHOOTABLE)
			{
				lastenemy = target;
				threshold = 0;
			}
			
			// got a new target
			if (LookForPlayers (true, null) && target != goal)
			{
				bINCHASE = false;
				return;
			}
			
			if (target == null)
			{
				if (bFRIENDLY)
				{
					if (target == null)
					{
						if (!dontmove) A_Wander();
						bINCHASE = false;
						return;
					}
				}
				else
				{
					SetIdle();
					bINCHASE = false;
					return;
				}
			}
		}
		
		// do not attack twice in a row
		if (bJUSTATTACKED)
		{
			bJUSTATTACKED = false;
			if (!isFast && !dontmove && !(flags & CHF_NOPOSTATTACKTURN) && !(flags & CHF_STOPIFBLOCKED))
			{
				NewChaseDir();
			}
			//Because P_TryWalk would never be reached if the actor is stopped by a blocking object,
			//need to make sure the movecount is reset, otherwise they will just keep attacking
			//over and over again.
			if (flags & CHF_STOPIFBLOCKED)
				movecount = TryWalk() & 15;
			bINCHASE = false;
			return;
		}
		
		// [RH] Don't attack if just moving toward goal
		if (target == goal || bChaseGoal && goal != null)
		{
			actor savedtarget = target;
			target = goal;
			double dist = Distance2D(savedtarget);
			bool result = (dist >= MeleeRange + radius + savedtarget.radius) ? true : false;
			target = savedtarget;
			
			if (result)
			{
				// reached the goal
				ActorIterator iterator = Level.CreateActorIterator(goal.args[0], "PatrolPoint");
				ActorIterator specit = Level.CreateActorIterator(goal.tid, "PatrolSpecial");
				Actor spec;
				
				// Execute the specials of any PatrolSpecials with the same TID
				// as the goal.
				while ( (spec = specit.Next()) )
				{
					level.ExecuteSpecial(
						spec.special, self, null, false,
						spec.args [0], spec.args [1], spec.args [2], spec.args [3], spec.args [4]
					);
				}
			
				double lastgoalang = goal.angle;
				int delay;
				actor newgoal = iterator.Next ();
				if (newgoal != null && goal == target)
				{
					delay = newgoal.args[1];
					reactiontime = delay * TICRATE + level.maptime;
				}
				else
				{
					delay = 0;
					reactiontime = Default.reactiontime;
					angle = lastgoalang;
				}
				if (target == goal) target = null;
				bJUSTATTACKED = true;
				if (newgoal != null && delay != 0)
				{
					bINCOMBAT = true;
					SetIdle();
				}
				bINCHASE = false;
				goal = newgoal;
				return;
			}
		}
		if (goal == target) A_PostalDoChaseEnd (fastChase, meleestate, missilestate, playActive, nightmareFast, dontMove, flags);
		
		// Strafe	(Hexen's class bosses)
		// This was the sole reason for the separate A_FastChase function but
		// it can be just as easily handled by a simple flag so the monsters
		// can take advantage of all the other enhancements of A_Chase.
		
		if (fastchase && !dontmove)
		{
			if (FastChaseStrafeCount > 0)
			{
				FastChaseStrafeCount--;
			}
			else
			{
				FastChaseStrafeCount = 0;
				Vel.X = Vel.Y = 0;
				double dist = Distance2D(target);
				if (dist < CLASS_BOSS_STRAFE_RANGE)
				{
					if (random[pr_chase](0,255) < 100)
					{
						double ang = AngleTo(target);
						if (random[pr_chase](0,255) < 128) ang += 90.;
						else ang -= 90.;
						VelFromAngle(13., ang);
						FastChaseStrafeCount = 3;	// strafe time
					}
				}
			}
		}
		
		// [RH] Scared monsters attack less frequently
		if (target.player == null || 
			!(target.player.cheats & CF_FRIGHTENING) || (target.bFRIGHTENING &&
			bFRIGHTENED) ||
			random[pr_scaredycat](0,255) < 43)
		{
			// check for melee attack
			if (meleestate && CheckMeleeRange ())
			{
				if (AttackSound)
					A_StartSound(AttackSound, CHAN_WEAPON);
				
				SetState (meleestate);
				bINCHASE = false;
				return;
			}
			
			// check for missile attack
			if (missilestate)
			{
				if(!isFast && movecount)
				{
					A_PostalDoChaseEnd (fastChase, meleestate, missilestate, playActive, nightmareFast, dontMove, flags);
				}
			
				if (!CheckMissileRange())
				{
					A_PostalDoChaseEnd (fastChase, meleestate, missilestate, playActive, nightmareFast, dontMove, flags);
				}
				SetState (missilestate);
				bJUSTATTACKED = true;
				bINCOMBAT = true;
				bINCHASE = false;
				return;
			}
		}
		
		A_PostalDoChaseEnd (fastChase, meleestate, missilestate, playActive, nightmareFast, dontMove, flags);
	}
	
	void A_PostalDoChaseEnd(bool fastchase, State meleestate, State missilestate, bool playActive, bool nightmareFast, bool dontMove, int flags)
	{
		if ((multiplayer || TIDtoHATE)
			&& !threshold
			&& !CheckSight(target,0) )
		{
			bool lookForBetter = false;
			bool gotNew;
			if (bNOSIGHTCHECK)
			{
				bNOSIGHTCHECK = false;
				lookForBetter = true;
			}
			actor oldtarget = target;
			gotNew = LookForPlayers(true,null);
			if (lookForBetter)
			{
				bNOSIGHTCHECK = true;
			}
			if (gotNew && target != oldtarget)
			{
				bINCHASE = false;
				return;
			}
		}
		
		//
		// chase towards player
		//
		
		if (strafecount)
			strafecount--;
			
		// class bosses don't do this when strafing
		if ((!fastchase || !FastChaseStrafeCount) && !dontmove)
		{
			// CANTLEAVEFLOORPIC handling was completely missing in the non-serpent functions.
			vector2 old = pos.XY;
			//int oldgroup = PrevPortalGroup
			TextureID oldFloor = floorpic;
			
			// Chase towards player
			if ((--movecount < 0 && !(flags & CHF_NORANDOMTURN)) || !MonsterMove() && !(flags & CHF_StopIfBlocked))
			{
				NewChaseDir();
			}
			// if the move was illegal, reset it 
			// (copied from A_SerpentChase - it applies to everything with CANTLEAVEFLOORPIC!)
			if (bCANTLEAVEFLOORPIC && floorpic != oldFloor)
			{
				if (TryMove(old, false))
				{
					if (nomonsterinterpolation)
					{
						Prev.X = old.X;
						Prev.Y = old.Y;
						//PrevPortalGroup = oldgroup;
					}
				}
				if (!(flags & CHF_STOPIFBLOCKED))
					NewChaseDir();
			}
		}
		else if (dontmove && movecount > 0) movecount--;
		
		// make active sound
		if (playactive && random[pr_chase](0,255) < 3)
		{
			PlayActiveSound();
		}
		
		bINCHASE = false;
		
	}
	
	action void A_PostalChase (StateLabel melee = null, StateLabel missile = null, int flags = 0)
	{
        invoker.A_PostalDoChase ((flags & CHF_FastChase), ResolveState (melee), ResolveState (missile), !(flags & CHF_NoPlayActive),
            (flags & CHF_NightmareFast), (flags & CHF_DontMove), flags
        );
    }
}

class PostalDecoration : Actor 
{
	override void Tick() { }
	
	Default
	{
		//+ROLLSPRITE
		//+ABSMASKPITCH
		//+ABSMASKANGLE
		//+NOGRAVITY
		//+SOLID
		//+NOINTERACTION
	}
}

class PostalInventory : Inventory { }

/*
extend class PostalDecoration
{
	// Model automatically adjusts pitch and roll based on slope
	bool user_adjustSlope;
	
	override void Tick()
	{
		Super.Tick();
		if (user_adjustSlope)
			AlignToPlane(self);
	}
	
	static void AlignToPlane(Actor a = null, double pitchAdjust = 0, bool ceiling = false, double adjustSpeed = 50.0)
    {
        double ceilingAdjust = 0;
        Vector3 fnormal;
        if (!ceiling)
        {
         fnormal = a.CurSector.FloorPlane.Normal;
        }
        else
        {
         fnormal = a.CurSector.CeilingPlane.Normal;
         ceilingAdjust = 180.0;
        }
        Vector2 fnormalp1 = (fnormal.x != 0 || fnormal.y != 0) ? (fnormal.x, fnormal.y).Unit() : (0, 0);
        Vector2 fnormalp2 = ((fnormal.x, fnormal.y).Length(), fnormal.z);
        double dang = a.Angle;
        double fang = atan2(fnormalp1.y, fnormalp1.x);
        double fpitch = atan2(fnormalp2.x, fnormalp2.y);
        double ddiff1 = sin(fang - (dang - pitchAdjust));
        double ddiff2 = cos(fang - dang);
 
        double pitchTarget = (fpitch * ddiff2 - pitchAdjust) + ceilingAdjust;
        double rollTarget = -fpitch * ddiff1 + ceilingAdjust;
        double angleTarget = dang + ceilingAdjust;
 
        if(a.Pitch < pitchTarget)
        {
            a.Pitch += adjustSpeed;
            if(a.Pitch > pitchTarget)
            {
                a.Pitch = pitchTarget;
            }
        }
        else if(a.Pitch > pitchTarget)
        {
            a.Pitch -= adjustSpeed;
            if(a.Pitch < pitchTarget)
            {
                a.Pitch = pitchTarget;
            }
        }
        if(a.Roll < rollTarget)
        {
            a.Roll += adjustSpeed;
            if(a.Roll > rollTarget)
            {
                a.Roll = rollTarget;
            }
        }
        else if(a.Roll > rollTarget)
        {
            a.Roll -= adjustSpeed;
            if(a.Roll < rollTarget)
            {
                a.Roll = rollTarget;
            }
        }
        if(a.Angle < angleTarget)
        {
            a.Angle += adjustSpeed;
            if(a.Angle > angleTarget)
            {
                a.Angle = angleTarget;
            }
        }
        else if(a.Angle > angleTarget)
        {
            a.Angle -= adjustSpeed;
            if(a.Angle < angleTarget)
            {
                a.Angle = angleTarget;
            }
        }
    }

}
*/

extend class PostalActor
{
	//Avoid targeting the following actors
	//Note: it's probably my broken checking (BlockThingsIterator) that's the issue here and not these actors below
	static const string AI_NeverTarget[] =
	{
		"PostalDoor",
		"PostalDoor_Extender",
		"PostalFire",
		"PostalLiquidGas",
		"RandomPostalFire",
		"PostalRocket",
		"PostalGrenade"
	};
	
	//===========================================================================
   //
   // AlignToPlane
   // Original code written by ZZYZX
   //
   //===========================================================================
 
    static void AlignToPlane(Actor a = null, double pitchAdjust = 0, bool ceiling = false, double adjustSpeed = 1.0)
    {
        if (!a) return;
        double ceilingAdjust = 0;
        Vector3 fnormal;
        if (!ceiling)
        {
         fnormal = a.CurSector.FloorPlane.Normal;
        }
        else
        {
         fnormal = a.CurSector.CeilingPlane.Normal;
         ceilingAdjust = 180.0;
        }
        Vector2 fnormalp1 = (fnormal.x != 0 || fnormal.y != 0) ? (fnormal.x, fnormal.y).Unit() : (0, 0);
        Vector2 fnormalp2 = ((fnormal.x, fnormal.y).Length(), fnormal.z);
        double dang = a.Angle;
        double fang = atan2(fnormalp1.y, fnormalp1.x);
        double fpitch = atan2(fnormalp2.x, fnormalp2.y);
        double ddiff1 = sin(fang - (dang - pitchAdjust));
        double ddiff2 = cos(fang - dang);
 
        double pitchTarget = (fpitch * ddiff2 - pitchAdjust) + ceilingAdjust;
        double rollTarget = -fpitch * ddiff1 + ceilingAdjust;
        double angleTarget = dang + ceilingAdjust;
 
        if(a.Pitch < pitchTarget)
        {
            a.Pitch += adjustSpeed;
            if(a.Pitch > pitchTarget)
            {
                a.Pitch = pitchTarget;
            }
        }
        else if(a.Pitch > pitchTarget)
        {
            a.Pitch -= adjustSpeed;
            if(a.Pitch < pitchTarget)
            {
                a.Pitch = pitchTarget;
            }
        }
        if(a.Roll < rollTarget)
        {
            a.Roll += adjustSpeed;
            if(a.Roll > rollTarget)
            {
                a.Roll = rollTarget;
            }
        }
        else if(a.Roll > rollTarget)
        {
            a.Roll -= adjustSpeed;
            if(a.Roll < rollTarget)
            {
                a.Roll = rollTarget;
            }
        }
        if(a.Angle < angleTarget)
        {
            a.Angle += adjustSpeed;
            if(a.Angle > angleTarget)
            {
                a.Angle = angleTarget;
            }
        }
        else if(a.Angle > angleTarget)
        {
            a.Angle -= adjustSpeed;
            if(a.Angle < angleTarget)
            {
                a.Angle = angleTarget;
            }
        }
    }
	
	NavMesh mesh;
    array<NavSector> path;
    Sector targetSector;

    override void PostBeginPlay()
    {
        mesh = NavMesh(ThinkerIterator.Create("NavMesh").Next());
    }

    // Chase target as long as it's in monster's sector, or monster has up-to-date path to it.
    action void A_Chase2(StateLabel meleeState = 'Melee', StateLabel rangedState = 'Missile',
                         StateLabel planState = 'See.Plan')
    {
        if (!target)
            return;

        // So Thing_SetGoal doesn't get in the way.
        if (target == goal)
            goal = null;

        Actor chaseTarget = null;
        int pathSize = invoker.path.Size();
        if (pathSize == 0 || invoker.targetSector != target.floorSector) // No up-to-date plan
        {
            SetStateLabel(planState);
            return;
        }
        else if (pathSize == 1) // We've reached target sector
        {
            chaseTarget = target;
        }
        else
        {
            if (goal && Distance2d(goal) < radius)  // Get rid of waypoint when reached
            {
                goal.Destroy();
                goal = null;
            }

            if (!goal)  // Create new waypoint, if needed
            {
                // Find link (line) b/w current sector, and next sector
                NavSector ns1 = invoker.path[invoker.path.Size()-1];
                NavSector ns2 = invoker.path[invoker.path.Size()-2];
                NavLink link;
                for (int i = 0; i < ns1.links.Size(); ++i)
                {
                    if (ns1.links[i].to == ns2)
                    {
                        link = ns1.links[i];
                        break;
                    }
                }

                // Go to link's midpoint
                vector3 nextPoint;
                nextPoint.x = link.midpoint.x;
                nextPoint.y = link.midpoint.y;
                nextPoint.z = GetZAt(nextPoint.x, nextPoint.y, 0,
                                     GZF_ABSOLUTEPOS | GZF_ABSOLUTEANG);

                goal = Spawn("PatrolPoint", nextPoint);

                invoker.path.Pop();

                // DEBUG
                //console.Printf("(ZScript:Pathfinder) Now heading to %d", ns2.mapSector.Index());
            }

            chaseTarget = goal;
        }

        // Possibly attack target
        if (target.bShootable && isHostile(target))
        {
            A_Chase(meleeState, rangedState, CHF_DONTMOVE);
        }

        // Find a direction to move
        // I realize I could use A_Chase for this, but actors spin around whenever they hit a new
        // sector, moving north-south. I assume that's a bug.
        int oldDir = moveDir;
        moveDir = (8 * AngleTo(chaseTarget, true) / 360) % 8;
        if (!TryWalk())
        {
            moveDir = oldDir;
            if(!TryWalk())
            {
                for (int i = 1; i <= 4; ++i)
                {
                    moveDir = (oldDir + i) % 8;
                    if (TryWalk())
                        break;

                    moveDir = (oldDir - i) % 8;
                    if (TryWalk())
                        break;
                }
            }
        }

        // Face movement direction
        angle = 360 * moveDir / 8;
        if (angle > 180)
            angle -= 360;
    }

    // Create plan to reach target, or wait if target is unreachable
    action void A_Star(StateLabel meleeState = 'Melee', StateLabel rangedState = 'Missile',
                       StateLabel seeState = 'See')
    {
        if (invoker.mesh.navSectors.Size() == 0)
            return;

        if (!target)
            return;

        // So Thing_SetGoal doesn't get in the way.
        if (target == goal)
            goal = null;

        if (target.floorSector != invoker.targetSector) // Target has moved to different sector
        {
            //console.Printf("(ZScript:Pathfinder) Planning path..."); // DEBUG

            // Get rid of old plan
            if (goal)
            {
                goal.Destroy();
                goal = null;
            }
            invoker.path.Clear();

            // Get sectors invoker & target are in
            NavSector startSector = invoker.mesh.navSectors[floorSector.Index()];
            NavSector targetSector = invoker.mesh.navSectors[target.floorSector.Index()];

            // Save target location, so we don't repeat the search immediately
            invoker.targetSector = target.floorSector;

            // Find shortest path b/w them w/ A* search

            // Fringe contains partial plans under consideration
            // In spite of appearances, it's actually a binary min-heap
            // This means that the plan w/ the shortest path is always first
            // It also means that adding/removing elements is complex (see below)
            array<Plan> fringe;

            // Initial plan
            fringe.Push(New('Plan'));
            fringe[0].path.Push(startSector);
            fringe[0].givenCost = 0;
            fringe[0].heuristicCost = Distance2d(target);   // Distance is a decent heuristic

            // Until we run out of ideas
            while (fringe.Size() > 0)
            {
                // Remove best partial plan from fringe
                Plan currentPlan = fringe[0];

                // Pop from heap
                {
                    // Replace root node w/ right-most leaf node
                    fringe[0] = fringe[fringe.Size()-1];
                    fringe.Pop();

                    // Let new root node trickle down until its cost is <= both its children's
                    int index = 0;
                    int childIndex1 = 1;
                    int childIndex2 = 2;

                    while (fringe.Size() > childIndex1) // Until new node is at bottom of heap
                    {
                        double cost = fringe[index].givenCost + fringe[index].heuristicCost;
                        double childCost1 = fringe[childIndex1].givenCost
                                          + fringe[childIndex1].heuristicCost;

                        // Find out which is cheapest: the node, or one of its children
                        int minIndex = index;

                        if (fringe.Size() > childIndex2)
                        {
                            double childCost2 = fringe[childIndex2].givenCost
                                              + fringe[childIndex2].heuristicCost;

                            if (childCost2 < childCost1 && childCost2 < cost)
                            {
                                minIndex = childIndex2;
                            }
                            else if (childCost1 < cost)
                            {
                                minIndex = childIndex1;
                            }
                        }
                        else if (childCost1 < cost)
                        {
                            minIndex = childIndex1;
                        }

                        // Swap node w/ child, if needed
                        if (index != minIndex)
                        {
                            Plan temp = fringe[index];
                            fringe[index] = fringe[minIndex];
                            fringe[minIndex] = temp;

                            index = minIndex;
                            childIndex1 = 2 * index + 1;
                            childIndex2 = childIndex1 + 1;
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                // If plan reaches goal, we're done
                NavSector lastSector = currentPlan.path[currentPlan.path.Size()-1];
                if (lastSector == targetSector)
                {
                    //console.Printf("(ZScript:Pathfinder) Path found!"); // DEBUG

                    // Clear closed set
                    for (int i = 0; i < invoker.mesh.navSectors.Size(); ++i)
                    {
                        invoker.mesh.navSectors[i].closed = false;
                    }

                    // Invoker.path is a stack, so sectors go into it in reverse order
                    for (int i = currentPlan.path.Size() - 1; i >= 0; --i)
                    {
                        invoker.path.Push(currentPlan.path[i]);
                    }

                    SetStateLabel(seeState);
                    return;
                }

                // Put last sector in closed set, so we don't check it again
                lastSector.closed = true;

                // Add plans w/ one more sector to fringe
                for (int i = 0; i < lastSector.links.Size(); ++i)
                {
                    NavLink link = lastSector.links[i];
                    NavSector nextSector = link.to;

                    // Don't add sectors in closed set
                    if (nextSector.closed)
                        continue;

                    // Don't add sector if too high/low to climb/fall
                    if (link.deltaZ < -maxDropOffHeight || link.deltaZ > maxStepHeight)
                        continue;

                    // Don't add sector if line to it blocks monsters
                    if (link.blockMonsters)
                        continue;

                    // Don't add sector if ceiling too low, unless it's a door
                    if (link.height < height && !link.door)
                        continue;

                    int index = fringe.Size();
                    fringe.Push(New('Plan'));

                    fringe[index].path.Copy(currentPlan.path);
                    fringe[index].path.Push(nextSector);

                    fringe[index].givenCost = currentPlan.givenCost + link.distance;

                    // There doesn't seem to be a built-in point-to-point distance function
                    {
                        double deltaX = target.pos.x - nextSector.center.x;
                        double deltaY = target.pos.y - nextSector.center.y;

                        fringe[index].heuristicCost += Sqrt(deltaX * deltaX + deltaY * deltaY);
                    }

                    // Heap insertion
                    // Let new node bubble up until its cost is >= its parent's
                    while (index > 0)
                    {
                        int parentIndex = (index - 1) / 2;

                        double cost = fringe[index].givenCost + fringe[index].heuristicCost;
                        double parentCost = fringe[parentIndex].givenCost
                                          + fringe[parentIndex].heuristicCost;

                        // Swap node w/ parent, if needed
                        if (parentCost > cost)
                        {
                            Plan temp = fringe[index];
                            fringe[index] = fringe[parentIndex];
                            fringe[parentIndex] = temp;

                            index = parentIndex;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }

            //console.Printf("(ZScript:Pathfinder) No path found!");  // DEBUG

            // Clear closed set
            for (int i = 0; i < invoker.mesh.navSectors.Size(); ++i)
            {
                invoker.mesh.navSectors[i].closed = false;
            }
        }

        // Possibly attack target
        if (target)
        {
            A_Chase(null, "Missile", CHF_DONTMOVE);
        }
    }
	
	Actor AnnoyingFire;
	int Delayy;
	
	action void A_CheckForTargets()
	{
		//many thanks to phantombeta!!
		double fov = 110; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, 500); // The number here is (possibly roughly) the maximum distance they can see
		
		while (it.Next () && it.Thing != null) {
			let next = it.Thing;
			
			if (!next.bShootable || next.bKilled || next.health < 1)
			{
				continue;
			}
			
			if (!(level.mapname ~== "titlemap"))
			{
				if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
				{
					continue;
				}
			}
			
			if (!CheckSight (next, SF_SeePastShootableLines)) // Not in sight
				continue;

			// Do things with the "next" pointer here
			
				if (next != null)
				{
					if (next is 'NPCCore' && !next.bKILLED) //|| next is 'Champ' || next is 'PostalCatInv')
					{
						A_PlaySound(SeeSound);
						target = next;
						SetStateLabel("See");
						Console.Printf("Target in sight!");
						return;
					}
					
					//Imo, this isn't much different from A_Look, but we do this anyway
					if (next is 'PostalDude')
					{
						let PlayerDude = PostalDude(next);
						if (PlayerDude.PlayerData.P_NoTarget != true)
						{
							A_PlaySound(SeeSound);
							target = next;
							SetStateLabel("See");
						}
					}
				}
			
			}
			
		}
		
		/*override void Tick()
		{
			Super.Tick();
			if (level.time > Delayy)
			{
				Delayy = level.time + 35 * 2;
				A_CheckForTargets();
			}
		}
		
		override void PostBeginPlay()
		{
			Super.PostBeginPlay();
			Delayy = level.time + 35 * 2;
		
		}
		*/
		
		virtual void A_PlaySelfSound() { A_PlaySound(SeeSound); }
			
			
}


extend class PostalInventory
{
	override void Touch (Actor toucher)
	{
		if (toucher is 'PostalDude')
		{
			let player = toucher.player;

			// If a voodoo doll touches something, pretend the real player touched it instead.
			if (player != NULL)
			{
				toucher = player.mo;
			}

			//bool localview = toucher.CheckLocalView();

			//if (!toucher.CanTouchItem(self))
			//	return;

			bool res;
			[res, toucher] = CallTryPickup(toucher);
			if (!res) return;

			// This is the only situation when a pickup flash should ever play.
			if (PickupFlash != NULL && !ShouldStay())
			{
				Spawn(PickupFlash, Pos, ALLOW_REPLACE);
			}

			if (!bQuiet)
			{
				//PrintPickupMessage(localview, PickupMessage ());

				// Special check so voodoo dolls picking up items cause the
				// real player to make noise.
				if (player != NULL)
				{
					PlayPickupSound (player.mo);
					if (!bNoScreenFlash)
					{
						player.bonuscount = BONUSADD;
					}
				}
				else
				{
					PlayPickupSound (toucher);
				}
			}							

			// [RH] Execute an attached special (if any)
			DoPickupSpecial (toucher);

			if (bCountItem)
			{
				if (player != NULL)
				{
					player.itemcount++;
				}
				level.found_items++;
			}

			if (bCountSecret)
			{
				Actor ac = player != NULL? Actor(player.mo) : toucher;
				ac.GiveSecret(true, true);
			}

			//Added by MC: Check if item taken was the roam destination of any bot
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (players[i].Bot != NULL && self == players[i].Bot.dest)
					players[i].Bot.dest = NULL;
			}
		
		}
	}



}