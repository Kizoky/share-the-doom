// The core of all Bystanders
// If spawned it will use Postal Dude's models, and Mike J's voice

class NPCPussy : NPCCore { }

class NPCCore : PostalActor
{	
	//Do they have a weapon, or not?
	//NPCs that have a weapon in Postal 2 are always fights back
	string Hostility, NPCWeapon;
	
	//Each NPC has an Unique ID, but mainly for the corpse feature so they won't forgot about it
	int UniqueID;
	int deadpeople[999999];
	int WalkingStyle;
	
	//NPC is currently in a state - or was
	//isAfterTarget is not necessarily meant for the Hostile NPCs, it's meant for all 4 variants, we do this to check if they do have a target
	bool isBusy, isAfterTarget, hasSeenCorpse, Petitioning, gotPissedOn;
	
	int PetitionNumber;
	
	string PistolObituary, ShotgunObituary, RocketLObituary, ScissorObituary, MacheteObituary, ScytheObituary, SledgeObituary, RifleObituary, FireObituary, NapalmObituary,
	MachineObituary, KickObituary, TazerObituary, BatonObituary, ShovelObituary, CowHeadObituary, GrenadeObituary, PlagueObituary;
	
	
	string NPC_Scream, NPC_Bump, NPC_PetitionDeny, NPC_PetitionAccept, NPC_Dickout, NPC_Laugh, NPC_Taunt, NPC_Cry, NPC_Pickup, NPC_Confusion, NPC_Cat, NPC_Dog, NPC_House, NPC_PissedOn;
	
	double MyVoice;
	
	//Logic variables
	
	Actor MyTarget, ActiveNode;
	bool StopGoingAfterNode;
	int NodeCooldown;
	
	// GZDoom Builder stuff here
	
	bool user_isCamping;
	bool user_attacksplayeronsight;
	string user_weapon;
	
	//This changes obituary depending on what weapon the Bystander is carrying
	//of course, the default obituary won't change if it doesn't have a randomized weapon.
	override String GetObituary(Actor victim, Actor inflictor, Name mod, bool playerattack)
	{
		if (NPCWeapon == "Pistol")
			return PistolObituary;
			
		if (NPCWeapon == "Shotgun")
			return ShotgunObituary;
			
		if (NPCWeapon == "RocketLauncher")
			return RocketLObituary;
		
		return Obituary;
	}
	
	//For custom obituaries set for NPCs
	virtual void NPC_Obituaries()
	{
		PistolObituary = "%o ate a bullet from a Bystander's pistol.";
		ShotgunObituary = "%o enjoyed a facefull of a Bystander's shotgun streaming load.";
		RocketLObituary = "Nobody told %o that a Bystander's rocket is lethal. Ouch!";
		ScissorObituary = "%o was running into a Bystander's scissor.";
		MacheteObituary = "%o was hacked to death by a Bystander's machete.";
		ScytheObituary = "%o was sliced to death by a Bystander's Scythe.";
		SledgeObituary = "%o was smashed to death by a Bystander's Sledge.";
		RifleObituary = "%o just contributed to a Bystander's sniper training. Nice job.";
		FireObituary = "%o just enjoyed a Tibetan Monk experience thanks to a Bystander's Fire.";
		NapalmObituary = "%o was charbroiled with seven secret herbs and spices by a Bystander's napalm.";
		MachineObituary = "%o kindly offered to hang onto a Bystander's excess ammo. What a nice guy.";
		KickObituary = "%o was actually KICKED to death by a Bystander. No, I'm not kidding.";
		TazerObituary = "%o was electrocuted by a Bystander's tazer.";
		BatonObituary = "%o did his Rodney King impersonation for a Bystander's baton.";
		ShovelObituary = "%o was pathetically bludgeoned to death like a total wuss by a Bystander's shovel.";
		CowHeadObituary = "%o inhaled that sweet aroma from a Bystander's severed cowhead.";
		GrenadeObituary = "%o got splashed into pieces by a Bystander's grenade.";
		PlagueObituary = "%o got invited to a plague season by a Bystander's WMD.";
	}
	
	virtual void NPC_Settings()
	{
		//Sounds are defined here for NPCs
		NPC_Scream = "male1/scream";
		NPC_Bump = "mikej/bump";
		NPC_PetitionDeny = "noway";
		NPC_Dickout = "mikej/dickout";
		
		//Walking styles are randomized, but you can set it manually if wanted
		WalkingStyle = random(1,6);
		
		//The pitch of the NPC's voice is randomized, except Krotchy's
		if (!(self is 'NPCKrotchy'))
			MyVoice = frandom(0.7,1.2);
		
		//Spawn head hitbox
		
		if (!(self is 'NPCKrotchy'))
		{
			class<actor> Head = "NPCHead";
			Actor MyHead = spawn(Head, self.pos, ALLOW_REPLACE);
			if (MyHead)
			{
				MyHead.Angle = self.Angle;
				let p = NPCHead(MyHead);
				p.Owner = self;
			}
		}
		
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		UniqueID = random(1,999999);
		isAfterTarget = false;
		
		////// 1 = Pussy; will shriek in whatever occusion
		////// 2 = Hostile; has a weapon, and will attack back if provoked
		////// 3 = Ally; ignores the player, will attack back if a certain amount of HP was lost because of the Player
		////// 4 = Companion; Same as like ally, with the exception that it will follow the Player on sight, and won't attack it no matter what
		int RandomizedHostility = random(1,2);
		
		switch(RandomizedHostility)
		{
			default:
			case 1:
				Hostility = "Pussy";
				break;
			case 2:
				Hostility = "Hostile";
				break;
		}
		
		if (user_attacksplayeronsight == true)
			Hostility = "Hostile";
		
		if (Hostility == "Hostile")
		{
			int RandomizedWeapon = random(1,2);
			
			switch(RandomizedWeapon)
			{
				default:
					Console.Printf("Warning, weapon for a Hostile NPC hasn't been set!");
					Destroy();
					break;
				case 1:
					NPCWeapon = "Pistol";
					break;
				case 2:
					NPCWeapon = "Shotgun";
					break;
			
			}
		}
		
		if (!(user_weapon == ""))
			NPCWeapon = user_weapon;
		
		NPC_Settings();
		NPC_Obituaries();
		
	}
	
	override void Tick()
	{
		Super.Tick();
		
		// Some absurd way of doing pathnodes, probably will be replaced by something greater
		// or it will be even worse
		
		if (ActiveNode != null && isBusy != true && isAfterTarget != true)
		{
			if (StopGoingAfterNode != true && ActiveNode != null)
			{
				Angle = AngleTo(ActiveNode);
			}
			
			if (StopGoingAfterNode == true && level.time > NodeCooldown + 60)
			{
				//let node = Postal_Node(ActiveNode);
				StopGoingAfterNode = false;
				A_BystanderNode();
			}
			//vector2 diff = (pos.xy - ActiveNode.pos.xy).Unit();
			if ((
					(Distance2D(ActiveNode) < 0.1) || 
					(Distance2D(ActiveNode) < 0.5) || 
					(Distance2D(ActiveNode) < 1) || 
					(Distance2D(ActiveNode) < 2) || 
					(Distance2D(ActiveNode) < 3) || 
					(Distance2D(ActiveNode) < 4) || 
					(Distance2D(ActiveNode) < 5) || 
					(Distance2D(ActiveNode) < 6) || 
					(Distance2D(ActiveNode) < 7) || 
					(Distance2D(ActiveNode) < 8) || 
					(Distance2D(ActiveNode) < 9) || 
					(Distance2D(ActiveNode) < 10)) && ActiveNode != null)
			{
				let node = Postal_Node(ActiveNode);
				if (node.NextNode != null)
					ActiveNode = node.NextNode;
				else
					ActiveNode = null;
					
				Console.Printf("null");
			}
		}
	}
	
	virtual void A_PostalTarget()
	{
		//The AI in Postal 2 is stupid, so we'll make a countdown later, after that the bool will get resetted
		//And if it sees a corpse again, it will start all over again
		//the hasSeenCorpse just prevents clearing the target
		
		if (target)
		{
		
			if (Hostility == "Pussy" && hasSeenCorpse != true && target != null)
			{
				if (target.bKILLED)
				{
					//Console.Printf("Target killed");
					isAfterTarget = false;
					bFRIGHTENED = false;
					Speed = Default.Speed;
					A_ClearTarget();
					ActiveNode = null;
					isBusy = false;
					SetStateLabel("Spawn");
				}
			}
			
			if (Hostility == "Hostile" && target != null)
			{
				if (target.Health < 1)
				{
					//Console.Printf("Target killed");
					isAfterTarget = false;
					bFRIGHTENED = false;
					Speed = Default.Speed;
					A_ClearTarget();
					ActiveNode = null;
					isBusy = false;
					SetStateLabel("Spawn");
				}
			}
		
		}
	}
	
	virtual void A_PussyScream()
	{
			int Prob = random(0,100);
			if (Prob > 78)
			{
				A_PlaySound(NPC_Scream,0 , 1.0, false, 1, false, MyVoice);
			}
	}
	
	virtual void A_HostileWalk(int variant)
	{
		switch(variant)
		{
			default:
				Console.Printf("Warning, HostileWalk variant hasn't been set for an NPC!");
				Destroy();
				break;
			case 1:
				A_PostalTarget();
				A_ConcentratedTarget();
				A_Recoil(-0.35);
				A_Chase(flags: CHF_STOPIFBLOCKED);
				break;
			case 2:
				A_PostalTarget();
				A_ConcentratedTarget();
				A_Recoil(-0.35);
				A_Chase();
				break;
		}
	}
	
	virtual void A_ConcentratedTarget()
	{
		if (MyTarget)
		{
			target = MyTarget;
		}
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (user_attacksplayeronsight != true)
		{
			if (source != self)
			{
				MyTarget = source;
				target = source;
			}
		}
		else
		{
			if (source.target is 'PostalDude')
			{
				MyTarget = source.target;
				target = source.target;
			}
			
			let pp = NPCCore(source);
			
			if (pp && pp.MyTarget is 'PostalDude')
			{
				MyTarget = pp.target;
				target = pp.target;
			}
		}
		
		if (source is 'PostalDude' && inflictor is 'Urine')
		{
			SetStateLabel("Debug");
			gotPissedOn = true;
			Console.Printf("Got em!");
			Health += damage;
		}
		
		if (inflictor is 'Bulletpuff')
		{
			//Console.Printf("Clip clip clip");
			A_PlaySound("hitflesh",0 | 4096);
		}
		
		if (inflictor is 'fakeTrainCollision')
		{
			Thrust(20);
			A_DamageSelf(Health);
			//p.SetStateLabel("Headless.Death");
			//SetStateLabel("Headless.Death");
			
		}
		
		MyTarget = source;
		target = source;
		
		return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	
	// Mimics Postal 2's weird slow rotation towards it's target
	// todo: Prevent NPCs to turn around if Angle is too high or too low
	
	virtual void A_FacePostalTarget()
	{
		float RotationSpeed = 16;
		
		if (target)
		{
			if (abs (deltaangle (angle, AngleTo (target))) < 10)
			{
				angle = AngleTo (target);
				return;
			}
			
			if (((AngleTo (target)) - angle + 360) % 360 < 180)
			{	
				A_SetAngle(angle+RotationSpeed, SPF_INTERPOLATE);
			}
			else A_SetAngle(angle-RotationSpeed, SPF_INTERPOLATE);
			
			Console.Printf("Angle To Target: %f", AngleTo (target));
			Console.Printf("Angle: %f", angle);
			
		}
		
	}
	
	virtual void A_CheckObstacleTarget()
	{
		// Checks if there's something in the way in front of the target
		// which then the NPC will randomly strafe left or right, probably just like in Postal 2
		
		//Let's get the pitch from A_FaceTarget
		A_FaceTarget(0,0);
		Console.Printf("Pitch: %d",pitch);
		//Let's check the Distance to the target
		double DistanceTarget = Distance2D(target);
		
		//Create LineTrace
		FLineTraceData lineData;
		LineTrace(angle,DistanceTarget,pitch,offsetz: height-12, data: LineData);
		
		if (LineData.HitType == TRACE_HitActor)
		{
			if (lineData.HitActor != target && !(lineData.HitActor is 'NPCHead'))
			{
				bool ff = random(0,1);
				
				Console.Printf("Someone's in my way");
				if (ff)
					Thrust(8, Angle - 90);
				else
					Thrust(8, Angle + 90);
					
				SetStateLabel("HostileChase");
			}
		}
	}
	
	Default
	{
		//$Category NPCs
		//$Title "Debug Dude"
		//$Sprite DUDEA0
		Health 150;
		Radius 13;
		Height 65;
		Speed 0;
		PainChance 256;
		Monster;
		SeeSound "";
		AttackSound "weapons/pistol";
		PainSound "dudehurt";
		DeathSound "dudehurt16";
		ActiveSound "";
		Obituary "%o was somehow got killed by a Bystander. What, how is that possible??";
		DropItem "None";
		//+NOTARGETSWITCH;
		+SOLID
		+SHOOTABLE
		+DROPOFF
		+PICKUP
		+NOTDMATCH
		-FRIENDLY
		+SLIDESONWALLS
		+CANPASS
		+CANPUSHWALLS
		+FLOORCLIP
		+WINDTHRUST
		+TELESTOMP
		+NOBLOCKMONST
		+SPECIAL
		+FORCEPAIN
		+AVOIDMELEE
		+DOHARMSPECIES
		+HARMFRIENDS
		+QUICKTORETALIATE
		+ALLOWPAIN
		-COUNTKILL
		+INTERPOLATEANGLES
		CameraHeight 59;
	}
	States
	{
	Petitioning:
		DUDE A 0 { vel.xy = (0,0); }
		DUDE A 0
		{
			isBusy = true;
			if (PetitionNumber != 3)
				PetitionNumber++;
			
			A_FacePostalTarget();
		}
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { A_FacePostalTarget(); target = MyTarget; }
		DUDE ABCDEFGHIJKLMNOP 3 { A_FacePostalTarget(); target = MyTarget; }
		PINK A 0 A_PlaySound(NPC_PetitionDeny,0);
		PINK ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { A_FacePostalTarget(); target = MyTarget; }
		DUDW A 0
		{
			//Clear our target, so we won't be going after it
			isBusy = false;
			Petitioning = false;
			A_ClearTarget();
		}
		//TNT1 A 0 ACS_Execute(1003,0);
		Goto Spawn;
	Debug:
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3
		{
			angle += 35;
		}
		Loop;
	Spawn:
		TNT1 A 0;
		DUDW A 0
		{
			if (target == null && Hostility == "Pussy" && Hostility == "Hostile")
			{
				isAfterTarget = false;
				isBusy = false;
			}
			
			if (target != null && Hostility == "Pussy")
			{
				A_PostalTarget();
			}
			
			if (isAfterTarget && hasSeenCorpse && Hostility == "Pussy")
			{
				SetStateLabel("See");
			}
			
			A_BystanderNode();
			
		}
		DUDW ABCD 3
		{
			A_Recoil(-0.35);
			A_Wander(flags: CHF_STOPIFBLOCKED);
			if (Petitioning == true)
				SetStateLabel("Petitioning");
			A_BystanderNode();
		}
		//TNT1 A 0 A_BystanderNode();
		DUDW EFGH 3
		{
			A_Recoil(-0.35);
			A_Wander(flags: CHF_STOPIFBLOCKED);
			A_BystanderNode();
		}
		DUDW I 0 A_BystanderThink();
		DUDW IJKL 3
		{
			A_Recoil(-0.35);
			A_Wander(flags: CHF_STOPIFBLOCKED);
			A_BystanderNode();
		}
		//TNT1 A 0 A_BystanderNode();
		DUDW MNOPQR 3
		{
			A_Recoil(-0.35);
			A_Wander(flags: CHF_STOPIFBLOCKED);
			A_BystanderNode();
		}
		Loop;
	See:
		DUDE A 0
		{	
			if (Hostility == "Pussy" && isAfterTarget == true)
			{
				bFRIGHTENED = true;
				Speed = 2;
				SetStateLabel("PussyChase");
				bNOTARGETSWITCH = true;
				
				//A_ConcentratedTarget();
				
			}
				
			if (Hostility == "Hostile" && isAfterTarget == true)
			{
				Speed = 1;
				SetStateLabel("HostileChase");
				
				A_ConcentratedTarget();
				
			}
		}
	FireChase:
		FIRE A 0
		{
			// temp fix: spawn dozen of NPCs, kill them instantly, all NPCs will enter this state if they saw them
			
			PainChance = 0;
			
			if (AnnoyingFire == null)
			{
				if (isBusy == true && isAfterTarget == true)
					SetStateLabel("See");
				else
					SetStateLabel("Spawn");
			
			}
		
		}
		FIRE ABCDEFGHIJ 3
		{
			PainChance = 0;
			A_Recoil(-0.35);
			A_Wander();
			Speed = 2;
		}
		FIRE J 0
		{
			A_PussyScream();
			if (AnnoyingFire == null) SetStateLabel("FireChaseEnd"); Speed = Default.Speed;
		}
		Loop;
	FireChaseEnd:
		SHOO A 0
		{
			// temp fix: spawn dozen of NPCs, kill them instantly, all NPCs will enter this state if they saw them
			
			if (AnnoyingFire == null)
			{
				if (isBusy == true && isAfterTarget == true)
					SetStateLabel("See");
				else
					SetStateLabel("Spawn");
			
			}
		
		}
		SHOO ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO2 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO3 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO4 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO5 ABCDEFGHIJKLMNOPQ 3;
		DUDW A 0 { AnnoyingFire.Destroy(); }
		DUDW A 0
		{
			PainChance = Default.PainChance;
			
			if (target != null)
			{
				if (Hostility == "Pussy")
				{
					bFRIGHTENED = true;
					Speed = 2;
					SetStateLabel("PussyChase");
					bNOTARGETSWITCH = true;
				}
				
				if (Hostility == "Hostile" && isAfterTarget == true)
				{
					Speed = 1;
					SetStateLabel("HostileChase");
					
					A_ConcentratedTarget();
				
				}	
			}
			else
				SetStateLabel("Spawn"); Speed = Default.Speed;
		}
		Goto See;
	PussyChase:
		FLEE ABCDEFGHIJ 3
		{
			if (target == null)
			{
				//Console.Printf("Target killed");
				isAfterTarget = false;
				bFRIGHTENED = false;
				Speed = Default.Speed;
				A_ClearTarget();
				SetStateLabel("Spawn");
			}
			
			A_PostalTarget();
			//A_ConcentratedTarget();
			A_Recoil(-0.85);
			A_Chase(null, null, flags: CHF_STOPIFBLOCKED);
		}
		FLEE A 0 A_PussyScream();
		Loop;
	HostileChase:
		TNT1 A 0
		{	
			A_ConcentratedTarget();
			Pitch = 0;
			
			if (NPCWeapon == "Pistol")
				SetStateLabel("HostileChase.Pistol");
			if (NPCWeapon == "Shotgun")
				SetStateLabel("HostileChase.Shotgun");
		
		}
	HostileChase.Pistol:
		XXXX A 0 { Pitch = 0; }
		XXXX ABCDEFGHIJKLMNOPQ 2 A_HostileWalk(1);
		XXXX ABCDEFGHIJKLMNOPQ 2 A_HostileWalk(2);
		Loop;
	HostileChase.Shotgun:
		SHOT A 0 { Pitch = 0; }
		SHOT ABCDEFGHIJKLMNOPQRSTU 2 A_HostileWalk(1);
		SHOT ABCDEFGHIJKLMNOPQRSTU 2 A_HostileWalk(2);
		Loop;
	Missile:
		TNT1 A 0
		{
			A_ConcentratedTarget();
			Pitch = 0;
			
			if (Hostility == "Hostile" && isAfterTarget == true)
			{
				if (NPCWeapon == "Pistol")
					SetStateLabel("Missile.Pistol");
				if (NPCWeapon == "Shotgun")
					SetStateLabel("Missile.Shotgun");
			}
		}
	Missile.Pistol:
		XXXF A 0 { vel.xy = (0,0); A_CheckObstacleTarget(); }
		XXXF A 10 A_FaceTarget(0,0);
		XXXF A 0 A_PostalTarget();
		XXXF A 6 A_NPCPistolAttack();
		XXXF A 8;
		XXXF A 0 A_ConcentratedTarget();
		Goto HostileChase.Pistol;
	Missile.Shotgun:
		SHOF A 0 { vel.xy = (0,0); A_CheckObstacleTarget(); }
		SHOF A 10 A_FaceTarget(0,0);
		SHOF A 0 A_PostalTarget();
		SHOF A 6 A_NPCShotgunAttack();
		SHOF A 4;
		SHOF A 0 A_PlaySound("weapons/shotgr", CHAN_WEAPON);
		SHOF A 6;
		SHOF A 0 A_ConcentratedTarget();
		Goto HostileChase.Shotgun;
	Pain:
		DUDE A 0 { if (gotPissedOn == true) { isAfterTarget = false; SetStateLabel("Debug"); }}
		DUDE A 0 { isBusy = false; isAfterTarget = true;}
		DUDE A 3 A_Pain;
		Goto See;
	Bumping:
		DUDE A 0 A_PlaySound(NPC_Bump,0, 1.0, false, 1, false, MyVoice);
		DUDE A 0 { vel.xy = (0,0); }
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { target = MyTarget; A_FacePostalTarget(); }
		
		DUDW A 0
		{
			//Clear our target, so we won't be going after it
			isBusy = false;
			A_ClearTarget();
		}
		Goto Spawn;
	Standing:
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		Goto Spawn;
	DickOut:
		DUDE A 0 A_PlaySound(NPC_Dickout,0 , 1.0, false, 1, false, MyVoice);
		DUDE A 0 { vel.xy = (0,0); }
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { target = MyTarget; A_FacePostalTarget(); }
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 2 { target = MyTarget; A_FacePostalTarget(); }
		
		DUDW A 0
		{
			//our target is the Player always in this state
			let PlayerDude = PostalDude(target);
			
			//Check if Player's onscreen weapon is Urethra, pretty self explanatory
			if (PlayerDude.Player.ReadyWeapon == PlayerDude.PlayerData.UrethraWeapon)
			{
				isBusy = false;
				A_ClearTarget();
				SetStateLabel("Spawn");
			}
			else
			{
				isBusy = false;
				A_ClearTarget();
			}
			//Although this may never happen (or can if the Player suddenly zipped it's pants), we don't want to make nasty mistakes.
			isBusy = false;
		}
		Goto Spawn;
	StaringWeapon:
		DUDE A 0 { vel.xy = (0,0); }
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { target = MyTarget; A_FacePostalTarget(); }
		//Be hostile, or flee from the frightening Player
		DUDE A 0 { isAfterTarget = true; A_PlaySound(NPC_Taunt,0); }
		Goto See;
	StaringNPC:
		DUDE A 0 { vel.xy = (0,0); }
		
		DUDE A 0 
		{
			
			
			
			let pp = NPCCore(MyTarget);
			
			//If the Unique ID attached to the corpse is the same in our deadpeople array, then forget about it
			//If this is the first time then just assign the element of deadpeople to the corpse's element
			//so the NPC will always ignore it, that is if it's a Hostile-type NPC
			
			if (pp)
			{
			
				if (deadpeople[pp.UniqueID] == pp.UniqueID && Hostility == "Hostile")
				{
					SetStateLabel("Spawn");
					return;
				}
				else
				{
					deadpeople[pp.UniqueID] = pp.UniqueID;
					hasSeenCorpse = true;
				}
			}
			
			
		}
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { target = MyTarget; A_FacePostalTarget(); }
		TNT1 A 0 
		{
			//Grab the target's variables
			let pp = NPCCore(target);
			//Console.Printf("NPCCore let pp");
			
			//If the NPC's (not target's) Hostility is 0
			if (isBusy == true)
			{
				if (target is 'NPCCore')
				{
					//Console.Printf("Hostility 0 yada yada");
					//If target's Hostility is 2 (Hostile)
					let pp = NPCCore(target);
					
					if (pp.Hostility == "Hostile")
					{
							let pp = NPCCore(target);
							//Console.Printf("NPCCore is my target");
							//Console.Printf("HE'S GOT A GUN!!!");
							if (Hostility == "Hostile")
							{
								target = pp;
								isBusy = false;
								A_PlaySound(NPC_Taunt,0);
								isAfterTarget = true;
								SetStateLabel("See");
								return;
							}
							
							if (Hostility == "Pussy")
							{
								target = pp;
								isBusy = false;
								isAfterTarget = true;
								SetStateLabel("See");
								return;
							}
					}
				}
				
				//todo: Add a StaringCorpse state
				if (target is 'NPCCore' && Hostility == "Pussy" && target.bCORPSE)
				{
					target = pp;
					isBusy = false;
					isAfterTarget = true;
					SetStateLabel("See");
				}
			}
			
		}
		Goto See;
	Death:
		DUDD A 0 A_Scream;
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		DUD2 A 0
		{
			if (NPCWeapon == "Pistol")
				A_SpawnItemEx("PostPistol");
			if (NPCWeapon == "Shotgun")
				A_SpawnItemEx("PostShotgun");
		
		}
		DUD2 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	Headless.Death:
		XYXY A 0 A_Scream;
		XYXY ABCDEFGHIJKLMNOPQRSTUVWXYZ 1;
		XYX2 A 0
		{
			if (NPCWeapon == "Pistol")
				A_SpawnItemEx("PostPistol");
			if (NPCWeapon == "Shotgun")
				A_SpawnItemEx("PostShotgun");
		
		}
		XYX2 A 0 A_NoBlocking;
		XYX2 ABCDEFGHIJKLMNOP 2;
		XYX2 P -1;
		Stop;
	XDeath:
		DUDD A 0 A_Scream;
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		DUD2 A 0
		{
			if (NPCWeapon == "Pistol")
				A_SpawnItemEx("PostPistol");
			if (NPCWeapon == "Shotgun")
				A_SpawnItemEx("PostShotgun");
		
		}
		DUD2 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	Raise:
		Stop;
	}
}

extend class NPCCore
{	
	//////////////////////////////////
	/////// Bump/Touch feature
	//////////////////////////////////
	
	override void Touch(Actor toucher)
	{
		if (toucher)
		{
			if (toucher is 'PostalDude')
			{
				let PlayerDude = PostalDude(toucher);
						
						// Let's check if there's Fire attached on the Player...
						if (PlayerDude.MyAnnoyingFire != null)
						{
							class<actor> Fire = "PostalFire";
							actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
							
							// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
							// but make sure to check it's not null or else GZDoom will crash
							if (AttachedFire)
							{
								let dd = PostalFire(AttachedFire);
								dd.Owner = self;
								dd.ThisOneHurts = true;
								dd.Counter = 0;
								
								if (AnnoyingFire != null)
								{
									//There's not enough time for the newly spawned Fire to cause damage
									AttachedFire.Destroy();
									
									dd.TimeBeforeDisappearing = level.time + (35 * 12);
								}
								else
									AnnoyingFire = AttachedFire;
							}
						}
						
						if (PlayerDude.MyAnnoyingFire == null && AnnoyingFire != null)
						{
							//woah dude you don't have a fire on you? Let me help you!
							
							if (PlayerDude.PlayerData.P_GodMode != true)
							{
							
								Console.Printf("Dude doesn't have fire");
								
								class<actor> Fire = "PostalFire";
								actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
								
								// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
								// but make sure to check it's not null or else GZDoom will crash
								if (AttachedFire)
								{
									let dd = PostalFire(AttachedFire);
									dd.Owner = PlayerDude;
									dd.ThisOneHurts = true;
									dd.Counter = 0;
									
									if (PlayerDude.MyAnnoyingFire != null)
									{
										//There's not enough time for the newly spawned Fire to cause damage
										AttachedFire.Destroy();
										
										dd.TimeBeforeDisappearing = level.time + (35 * 12);
									}
									else
										PlayerDude.MyAnnoyingFire = AttachedFire;
								}
							}
						}
			}
			
				//Note: This could have been in toucher.NPCCore aswell, but since we are aiming for the Fire to be kinda "universal"
				//I put it here - who knows maybe in the future I'll figure out how can I make the Fire attach to any custom monster without
				//relying on PostalActor
				if (toucher is 'PostalActor')
				{	
						let asd = PostalActor(toucher);
						if (asd.AnnoyingFire != null)
						{
							class<actor> Fire = "PostalFire";
							actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
							
							// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
							// but make sure to check it's not null or else GZDoom will crash
							if (AttachedFire)
							{
								let dd = PostalFire(AttachedFire);
								dd.Owner = self;
								dd.ThisOneHurts = true;
								dd.Counter = 0;
								
								if (AnnoyingFire != null)
								{
									//There's not enough time for the newly spawned Fire to cause damage
									AttachedFire.Destroy();
									
									dd.TimeBeforeDisappearing = level.time + (35 * 12);
								}
								else
									AnnoyingFire = AttachedFire;
							}
							
							//Let's exit anyway
							return;
						}
						
						if (asd.AnnoyingFire == null && AnnoyingFire != null)
						{
							class<actor> Fire = "PostalFire";
							actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
							
							// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
							// but make sure to check it's not null or else GZDoom will crash
							if (AttachedFire)
							{
								let dd = PostalFire(AttachedFire);
								dd.Owner = asd;
								dd.ThisOneHurts = true;
								dd.Counter = 0;
								
								if (AnnoyingFire != null)
								{
									//There's not enough time for the newly spawned Fire to cause damage
									AttachedFire.Destroy();
									
									dd.TimeBeforeDisappearing = level.time + (35 * 12);
								}
								else
									asd.AnnoyingFire = AttachedFire;
							}
							
							return;
						}
				
				}
			
			
			//If we aren't staring, nor we have more than 0 HP, or we aren't hostile atm, do:
			//Checking for 0 HP is needed because we don't want to resurrect dead NPCs into Ghost ones that are unkillable
			
			if (isAfterTarget != true && health > 0 && isBusy != true)
			{
				//target = toucher;
				// If the target is Postal Dude, do this
				if (toucher is 'PostalDude' && isAfterTarget != true)
				{
					let PlayerDude = PostalDude(toucher);
					if (isAfterTarget == false)
					{
						
						if (PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostCowhead")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostGrenade")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostMachete")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostM16")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostMolotov")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostNapalmLauncher")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostPistol")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostRLauncher")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostScissors")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostScythe")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostShotgun")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostRifle")) || 
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostUrethra")) ||
						PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostWMD")) ||
						user_attacksplayeronsight == true
						)
						{
							//Console.Printf("omg lethal weapon");
										//Console.Printf("HE'S GOT A GUN!!!");
										if (Hostility == "Hostile")
										{
											target = PlayerDude;
											MyTarget = PlayerDude;
											isAfterTarget = true;
											A_PlaySound(NPC_Taunt,0 , 1.0, false, 1, false, MyVoice);
											SetStateLabel("HostileChase");
										}
										else
										{
											if (Hostility == "Pussy")
											{
												target = PlayerDude;
												MyTarget = PlayerDude;
												isAfterTarget = true;
												SetStateLabel("See");
											}
										}
						}
						else
						{
							target = PlayerDude;
							MyTarget = PlayerDude;
							A_FacePostalTarget();
							isBusy = true;
							SetStateLabel("Bumping");
						}
					}
				}
				
				
				// If our target is another NPCCore, then do the following
				if (toucher is 'NPCCore' && isAfterTarget != true)
				{
						let pp = NPCCore(toucher);
						//If we aren't Hostile or Fleeing, do:
						//Calm, normal wandering/walking
						
						if (isAfterTarget == true) return;
						
						if (pp.isAfterTarget == false)
						{
							if (StopGoingAfterNode != true)
							{
								NodeCooldown = level.time;
								StopGoingAfterNode = true;
								ActiveNode = null;
							}
						}
						else
						{
							//Fleeing, running around and screaming like hell
							if (pp.Hostility == "Pussy" && pp.isAfterTarget == true)
							{
								//Console.Printf("STOP RUNNING INTO ME YOU SCREAMING PUSSY");
								A_FacePostalTarget();
								target = pp;
								MyTarget = pp;
								isBusy = true;
								SetStateLabel("Bumping");
							}
							else
							{
								//Hostile, attacks the target
								//If we aren't fleeing or Hostile, do:
								if (isAfterTarget != true)
								{
								
									if (pp.Hostility == "Hostile" && pp.isAfterTarget == true)
									{
										//Console.Printf("HE'S GOT A GUN!!!");
										if (Hostility == "Hostile")
										{
											target = pp;
											MyTarget = pp;
											isAfterTarget = true;
											A_PlaySound(NPC_Taunt,0 , 1.0, false, 1, false, MyVoice);
											SetStateLabel("HostileChase");
										}
										else
										{
											if (Hostility == "Pussy")
											{
												isAfterTarget = true;
												target = pp;
												MyTarget = pp;
												SetStateLabel("See");
											}
										}
										
									}
								
								}
							}
						}
				}
				
				if (toucher is 'Champ' && isAfterTarget != true)
				{
					SetStateLabel("Spawn");
				}
				
				if (toucher is 'PostalCatInv' && isAfterTarget != true)
				{
					SetStateLabel("Spawn");
				}
				
				if (toucher is 'CowMike' && isAfterTarget != true)
				{			
					if (Hostility == "Hostile")
					{
						target = toucher;
						MyTarget = toucher;
						isAfterTarget = true;
						A_PlaySound(NPC_Taunt,0 , 1.0, false, 1, false, MyVoice);
						SetStateLabel("HostileChase");
					}
					else
					{
						if (Hostility == "Pussy")
						{
							isAfterTarget = true;
							target = toucher;
							MyTarget = toucher;
							SetStateLabel("See");
						}
					}
				
				}
				
			}
			
		}	
	}
	
	//////////////////////////////////
	/////// "See" logic
	//////////////////////////////////
	
	action void A_BystanderThink()
	{
		//many thanks to phantombeta!!
		
		double fov = 90; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, 400); // The number here is (possibly roughly) the maximum distance they can see
		Actor unknownentity;
		
		if (invoker.Petitioning == true)
				SetStateLabel("Petitioning");
		
		while (it.Next () && it.Thing != null) {
				let next = it.Thing;
			
			/*
			if (!next.bShootable || next.bKilled || next.health < 1)
			{
				continue;
			}
			*/
			
			if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
			{
				continue;
			}

			
			if (!CheckSight (next, SF_SeePastShootableLines)) // Not in sight
				continue;

			// Do things with the "next" pointer here
						
						if (invoker.isAfterTarget != true)
						{
							if (next is 'PostalDude' && !(next.bKILLED))
							{
								let PlayerDude = PostalDude(next);
								if (PlayerDude != null && PlayerDude.player.ReadyWeapon != null)
								{
									if (PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostUrethra")))
									{
										//A_PlaySound("grunt/sight",0);
										invoker.isBusy = true;
										invoker.MyTarget = PlayerDude;
										vel.xy = (0,0);
										SetStateLabel("DickOut");
									}
									else
										if (PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostCowhead")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostGrenade")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostMachete")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostM16")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostMolotov")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostNapalmLauncher")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostPistol")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostRLauncher")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostScissors")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostScythe")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostShotgun")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostRifle")) || 
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostUrethra")) ||
										PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostWMD")) ||
										invoker.user_attacksplayeronsight == true
										)
										{
												invoker.isBusy = true;
												invoker.MyTarget = PlayerDude;
												vel.xy = (0,0);
												SetStateLabel("StaringWeapon");
										}
								}
							}
							
							
							if (next is 'NPCCore' && next != self)
							{
								let pp = NPCCore(next);
								if (pp.bCORPSE)
								{
									if (!(invoker.deadpeople[pp.UniqueID] == pp.UniqueID))
									{
										//invoker.staringAt = next;
										invoker.isBusy = true;
										invoker.MyTarget = next;
										target = next;
										vel.xy = (0,0);
										SetStateLabel("StaringNPC");
									}
								}
								
								if (pp.Hostility == "Hostile" && pp.isAfterTarget == true && !pp.bKILLED)
								{
									//Console.Printf("I see NPCCore");
									//invoker.staringAt = next;
									invoker.isBusy = true;
									if (invoker.user_attacksplayeronsight != true)
									{
										invoker.MyTarget = next;
										target = next;
										vel.xy = (0,0);
										SetStateLabel("StaringNPC");
									}
									else
									{
										if (pp.target is 'PostalDude' || pp.MyTarget is 'PostalDude')
										{
											target = next.target;
											invoker.MyTarget = next.target;
										}
									}
								}
							}
							
							if (next.bIsMonster && !(next.bKILLED) && !(next is 'NPCCore') && !(next is 'Champ') && !(next is 'PostalCatInv') && !(next is 'PostalLiquidGas') && !(next is 'PostalFire') && !(next is 'PouringGas') 
							&& !(next is 'RandomPostalFire') && !(next is 'FireParticleBottom') && !(next is 'FireSmokeUp') && !(next is 'PostalDoor') && !(next is 'PostalDoor_Extender'))
							{
								invoker.isAfterTarget = true;
								A_PlaySound(invoker.NPC_Taunt,0 , 1.0, false, 1, false, invoker.MyVoice);
								invoker.MyTarget = next;
								target = next;
								vel.xy = (0,0);
								SetStateLabel("See");
							}
							
							if (next is 'CowMike' && !next.bKILLED)
							{
							
									Actor madcow = next;
									
										if (invoker.Hostility == "Hostile")
										{
											invoker.isAfterTarget = true;
											A_PlaySound(invoker.NPC_Taunt,0 , 1.0, false, 1, false, invoker.MyVoice);
											invoker.MyTarget = madcow;
											vel.xy = (0,0);
											SetStateLabel("See");
										}
										else
										{
											if (invoker.Hostility == "Pussy")
											{
												invoker.isAfterTarget = true;
												invoker.MyTarget = madcow;
												vel.xy = (0,0);
												SetStateLabel("See");
											}
										}
							
							}
							
						}
						
					//A_ClearTarget();
			}
    }
	
	action void A_NPCPistolAttack()
	{
		if (target)
		{
			vel.xy = (0,0);
			invoker.A_FacePostalTarget();
			double ang = angle;
			double slope = AimLineAttack(ang, MISSILERANGE);
			A_PlaySound("weapons/pistol", CHAN_WEAPON);
			//ang  += Random2[PosAttack]() * (22.5/256);
			int damage = Random[PosAttack](1, 5) * 3;
			LineAttack(ang, MISSILERANGE, slope, damage, "Hitscan", "Bulletpuff", 0, null, 30, 0.5);
		}
	}
	
	action void A_NPCShotgunAttack()
	{
		if (target)
		{
			vel.xy = (0,0);
			invoker.A_FacePostalTarget();
			double bangle = angle;
			double slope = AimLineAttack(bangle, MISSILERANGE);
			
			A_PlaySound("weapons/shotgf", CHAN_WEAPON);
			
			for (int i=0 ; i<3 ; i++)
			{
				double ang = bangle; // + Random2[SPosAttack]() * (22.5/256);
				int damage = Random[SPosAttack](1, 5) * 3;
				LineAttack(ang, MISSILERANGE, slope, damage, "Hitscan", "Bulletpuff", 0, null, 30, 0.5);
			}
		}
    }
	
	action void A_BystanderNode()
	{
		//many thanks to phantombeta!!
		double fov = 160; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, 512); // The number here is (possibly roughly) the maximum distance they can see
		
		while (it.Next ()) {
				let next = it.Thing;
				
				//if (!next.bShootable) // || next.bKilled || next.health < 1)
				//{
				//	continue;
				//}
				
				
				if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
				{
					continue;
				}
				
				
				if (!CheckSight (next, SF_SeePastShootableLines)) // Not in sight
					continue;
				
				if (invoker.ActiveNode == null)
				{
					if (next is 'Postal_Node')
					{
							//double diff = deltaangle(angle, AngleTo(next));
							//double delta = abs(diff);
							
							invoker.ActiveNode = next;
							//Angle += AngleTo(next);
							//Console.Printf("I see a Postal_Node.");
							return;
					}
				}
						
			}
    }
}