class NPCCop : NPCCore { } // todo: port to latest codebase
class NPCShop : NPCCore { } // todo: port to latest codebase

// The core of all Bystanders
// If spawned it will use Postal Dude's model
// in the future this actor will be marked as abstract and it will not be possible to spawn it
// For creating custom NPCs please check "Postal.Bystanders.Example.txt" found in the same directory 

class NPCCore : PostalActor
{	
	//Do they have a weapon, or not?
	//NPCs that have a weapon in Postal 2 are always fights back
	string Hostility, NPCWeapon;
	
	//Each NPC has an Unique ID, but mainly for the corpse feature so they won't forgot about it
	int UniqueID;
	int deadpeople[999999];
	int WalkingStyle;
	
	//NPC is currently in a state - or was
	//isAfterTarget is not necessarily meant for the Hostile NPCs, it's meant for all 4 variants, we do this to check if they do have a target
	bool isBusy, isAfterTarget, hasSeenCorpse, Petitioning, gotPissedOn;
	
	int PetitionNumber;
	
	string PistolObituary, ShotgunObituary, RocketLObituary, ScissorObituary, MacheteObituary, ScytheObituary, SledgeObituary, RifleObituary, FireObituary, NapalmObituary,
	MachineObituary, KickObituary, TazerObituary, BatonObituary, ShovelObituary, CowHeadObituary, GrenadeObituary, PlagueObituary;
	
	
	sound NPC_Scream, NPC_Bump, NPC_PetitionDeny, NPC_PetitionAccept, NPC_Dickout, NPC_Laugh, NPC_Taunt, NPC_Panic, NPC_Cry, NPC_Pickup, NPC_Confusion, NPC_Cat, NPC_Dog, NPC_House, NPC_PissedOn, NPC_Bully, NPC_Reaction;
	
	double MyVoice;
	
	actor HeadHitbox;
	
	//Logic variables
	
	Actor MyTarget, ActiveNode;
	bool StopGoingAfterNode;
	int NodeCooldown;
	
	// Surrounding variables
	
	bool G_GotTauntedAt, G_SawInteresting, G_WTF;
	
	// GZDoom Builder stuff here
	
	bool user_StandingInOnePlace;
	bool user_attacksplayeronsight;
	bool user_corpse;
	string user_weapon;
	
	// Used for debugging
	enum DebugHostility
	{
		D_NONE,
		D_PUSSY,
		D_HOSTILE,
	}
	
	int debug_hostility;
	string debug_weapon;
	
	property debug_hostility : debug_hostility;
	property debug_weapon : debug_weapon;
	
	// Planned properties for future updates
	
	int stdVoice, stdWalkStyle, stdRunStyle, stdSkin, stdGroup, stdType, stdWeapon, stdFollower, stdGoesPostal, stdInvincible, stdIgnorePlayer, stdName, stdRandomGoodies, stdAttackPlayer;
	string stdObituary;
	property stdObituary : stdObituary;
	
	property CustomBehavior : BehaviorOverriden;
	
	virtual void NPC_Debug()
	{
		if (debug_hostility == D_NONE) return;
			
		if (debug_hostility == D_PUSSY || debug_hostility == D_HOSTILE)
		{
			let NewNPC = spawn("NPCCore", self.pos);
			if (NewNPC)
			{
				NewNPC.angle = angle;
				
				let SuperDuperNPC = NPCCore(NewNPC);
				if (SuperDuperNPC)
				{
					if (debug_hostility == D_PUSSY)
					{
						SuperDuperNPC.BehaviorOverriden = true;
						SuperDuperNPC.Hostility = "Pussy";
						SuperDuperNPC.NPCWeapon = "none";
						Destroy();
						return;
					}
					else
					{
						SuperDuperNPC.BehaviorOverriden = true;
						SuperDuperNPC.Hostility = "Hostile";
						SuperDuperNPC.NPCWeapon = debug_weapon;
						Destroy();
					}
				}
			}
		}
	}
	
	static const string WeaponList[] =
	{
		"Pistol",
		"Shotgun",
		"RLauncher"
		/*
		"Scissors",
		"Machete",
		"Scythe",
		"Sledge",
		"Rifle",
		"Molotov",
		"Napalm",
		"M16",
		"Hands",
		"Tazer",
		"Baton",
		"Shovel",
		"Cowhead",
		"Grenade",
		"WMD"
		*/
	};
	
	//For custom obituaries set for NPCs
	//Make sure the order is correct with WeaponList[]
	static const string NPC_Obituaries[] =
	{
		"$PSTL_NPC_PISTOL",
		"$PSTL_NPC_SHOTGUN",
		"$PSTL_NPC_ROCKET"
		/*
		"$PSTL_NPC_SCISSORS",
		"$PSTL_NPC_MACHETE",
		"$PSTL_NPC_SCYTHE",
		"$PSTL_NPC_SLEDGEHAMMER",
		"$PSTL_NPC_RIFLE",
		"$PSTL_NPC_FIRE",
		"$PSTL_NPC_NAPALM",
		"$PSTL_NPC_M16",
		"$PSTL_NPC_KICK",
		"$PSTL_NPC_TAZER",
		"$PSTL_NPC_BATON",
		"$PSTL_NPC_SHOVEL",
		"$PSTL_NPC_COWHEAD",
		"$PSTL_NPC_GRENADE",
		"$PSTL_NPC_WMD"
		*/
	};
	
	//This changes obituary depending on what weapon the Bystander is carrying
	//of course, the default obituary won't change if it doesn't have a randomized weapon.
	override String GetObituary(Actor victim, Actor inflictor, Name mod, bool playerattack)
	{
		if (!(stdObituary == "default"))
			return stdObituary;
		
		for(int i = 0; i < WeaponList.Size(); i++)
		{
			if (NPCWeapon ~== WeaponList[i])
			{
				return NPC_Obituaries[i];
			}
		}
		
		return Obituary;
	}
	
	virtual void NPC_Settings()
	{
		//Sounds are defined here for NPCs
		NPC_Scream = "male1/scream";
		NPC_Bump = "mikej/bump";
		NPC_PetitionDeny = "noway";
		NPC_Dickout = "mikej/dickout";
		NPC_Laugh = "male1/laugh";
		NPC_Taunt = "";
		NPC_Panic = "";
		NPC_Cry = "";
		NPC_Pickup = ""; // Played when they find something interesting on the ground and they pick it up
		NPC_Confusion = ""; // Played when something happens in the background (Huh, what, what the)
		NPC_Cat = ""; // Damn cat!
		NPC_Dog = ""; // Stupid mutt!
		NPC_House = ""; // Saw intruder in own house
		NPC_PissedOn = "";
		NPC_Bully = "";
		NPC_Reaction = ""; //Generic Reaction
		
		//Walking styles are randomized, but you can set it manually if wanted
		WalkingStyle = random[mystyle](1,6);
		
		//The pitch of the NPC's voice is randomized, except Krotchy's
		if (!(self is 'NPCKrotchy'))
			MyVoice = frandom[voicef](0.7,1.2);
		
		if (!(self is 'NPCKrotchy'))
		{
			//Spawn head hitbox
			class<actor> Head = "NPCHead";
			Actor MyHead = spawn(Head, self.pos, ALLOW_REPLACE);
			if (MyHead)
			{
				MyHead.Angle = self.Angle;
				let p = NPCHead(MyHead);
				if (p)
				{
					p.Owner = self;
					HeadHitbox = p;
				}
			}
			
			//Spawn Left and Right Arm
			
			/*
			
			int i = 1;
			while (i <= 2)
			{
				class<actor> Arm = "NPCArm";
				Actor MyArm = spawn(Arm, self.pos, ALLOW_REPLACE);
				if (MyArm)
				{
					MyArm.Angle = self.Angle;
					let p = NPCArm(MyArm);
					if (p)
					{
						p.master = self;
						if (i == 2)
							p.L = true;
					}
				}
				i++;
			}
			
			//Spawn Left and Right Leg
			
			int j = 1;
			while (j <= 2)
			{
				class<actor> Leg = "NPCLeg";
				Actor MyLeg = spawn(Leg, self.pos, ALLOW_REPLACE);
				if (MyLeg)
				{
					MyLeg.Angle = self.Angle;
					let p = NPCLeg(MyLeg);
					if (p)
					{
						p.master = self;
						if (j == 2)
							p.L = true;
					}
				}
				j++;
			}
			*/
			
		}
		
	}
	
	bool BehaviorOverriden;
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		NPC_Debug();
		
		//Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor", (1.0,0.0,0.0) );
		UniqueID = random[unique](1,999999);
		isAfterTarget = false;
		
		if (BehaviorOverriden != true)
		{
			////// 1 = Pussy; will shriek in whatever occusion
			////// 2 = Hostile; has a weapon, and will attack back if provoked
			////// 3 = Ally; ignores the player, will attack back if a certain amount of HP was lost because of the Player
			////// 4 = Companion; Same as like ally, with the exception that it will follow the Player on sight, and won't attack it no matter what
			int RandomizedHostility = random[myhostility](1,2);
			
			switch(RandomizedHostility)
			{
				default:
				case 1:
					Hostility = "Pussy";
					break;
				case 2:
					Hostility = "Hostile";
					break;
			}
			
			if (user_attacksplayeronsight == true)
				Hostility = "Hostile";
			
			if (Hostility == "Pussy")
				NPCWeapon = "none";
			
			if (Hostility == "Hostile")
			{
				int i = random[myweapon](0,WeaponList.Size()-1);
				
				NPCWeapon = WeaponList[i];
			}
			
			if (!(user_weapon == ""))
				NPCWeapon = user_weapon;
		}
		
		NPC_Settings();
		//NPC_Obituaries();
		
		if (user_StandingInOnePlace)
			SetStateLabel("Standing");
			
		if (user_corpse)
			A_DamageSelf(Health);
		
	}
	
	virtual void NPC_Tick()
	{
		if (bKILLED) return;
		
		if (isFrozen()) return;
		
		// If our head hitbox is missing, most likely we are immortal
		
		if (HeadHitBox == null && !(self is 'NPCKrotchy'))
		{
			if (!bKILLED)
				A_Die();
		}
		
		// Some absurd way of doing pathnodes, probably will be replaced by something greater
		// or it will be even worse
		
		if (ActiveNode != null && isBusy != true && isAfterTarget != true)
		{
			if (StopGoingAfterNode != true && ActiveNode != null)
			{
				Angle = AngleTo(ActiveNode);
			}
			
			if (StopGoingAfterNode == true && level.time > NodeCooldown + 60)
			{
				//let node = Postal_Node(ActiveNode);
				StopGoingAfterNode = false;
				A_BystanderNode();
			}
			//vector2 diff = (pos.xy - ActiveNode.pos.xy).Unit();
			if ((
					(Distance2D(ActiveNode) < 0.1) || 
					(Distance2D(ActiveNode) < 0.5) || 
					(Distance2D(ActiveNode) < 1) || 
					(Distance2D(ActiveNode) < 2) || 
					(Distance2D(ActiveNode) < 3) || 
					(Distance2D(ActiveNode) < 4) || 
					(Distance2D(ActiveNode) < 5) || 
					(Distance2D(ActiveNode) < 6) || 
					(Distance2D(ActiveNode) < 7) || 
					(Distance2D(ActiveNode) < 8) || 
					(Distance2D(ActiveNode) < 9) || 
					(Distance2D(ActiveNode) < 10)) && ActiveNode != null)
			{
				let node = Postal_Node(ActiveNode);
				if (!node) return;
				if (node.NextNode != null)
					ActiveNode = node.NextNode;
				else
					ActiveNode = null;
					
				//Console.Printf("null");
			}
		}
		
		if (InStateSequence(CurState, ResolveState("StaringWeapon")) ||
			InStateSequence(CurState, ResolveState("StaringNPC")) ||
			InStateSequence(CurState, ResolveState("StaringCorpse")) ||
			InStateSequence(CurState, ResolveState("Bumping")) ||
			InStateSequence(CurState, ResolveState("Stare")))
		A_FacePostalTarget();
		
		if (InStateSequence(CurState, ResolveState("Missile.Pistol")) ||
			(InStateSequence(CurState, ResolveState("Missile.Shotgun")) ||
			(InStateSequence(CurState, ResolveState("Missile.RLauncher")))))
		A_FaceTarget();
		
		// I want to kill myself
		if (InStateSequence(CurState, ResolveState("Spawn")))
		{	
			// Doom AI tries to default it's target to Player ALWAYS if they have seen it beforehand
			// This is getting annoying you know
			if (target && target is 'PlayerPawn')
			{
				if (MyTarget == null)
				{
					A_ClearTarget();
					Speed = Default.Speed;
				}
				else if (MyTarget != target)
					target = MyTarget;
			}
			
			// If both doesn't exist it's obvious they shouldn't be after targets or be busy
			if (!target && !MyTarget)
			{
				isAfterTarget = false;
				isBusy = false;
				Speed = Default.Speed;
			}
			
			if (target && MyTarget)
			{
				if (target == MyTarget && !target.bKILLED)
				{
					SetStateLabel("See");
				}
			}
			
			if (target == null && MyTarget != null)
			{
				if (!MyTarget.bKILLED)
				{
					target = MyTarget;
					SetStateLabel("See");
				}
				else
				{	
					target = null;
					MyTarget = null;
					isAfterTarget = false;
					Speed = Default.Speed;
				}
			}
		}
	}
	
	override void Tick()
	{
		Super.Tick();
		NPC_Tick();
	}
	
	virtual void A_PostalTarget()
	{
		//The AI in Postal 2 is stupid, so we'll make a countdown later, after that the bool will get resetted
		//And if it sees a corpse again, it will start all over again
		//the hasSeenCorpse just prevents clearing the target
		
		if (target)
		{
			if (Hostility == "Pussy" && !hasSeenCorpse)
			{
				if (target.bKILLED)
				{
					//Console.Printf("Target killed");
					isAfterTarget = false;
					bFRIGHTENED = false;
					Speed = Default.Speed;
					if (MyTarget == target && MyTarget)
						MyTarget = null;
					A_ClearTarget();
					ActiveNode = null;
					isBusy = false;
					SetStateLabel("Spawn");
				}
			}
			
			if (Hostility == "Hostile")
			{
				if (target.Health < 1)
				{
					//Console.Printf("Target killed");
					isAfterTarget = false;
					bFRIGHTENED = false;
					Speed = Default.Speed;
					if (MyTarget == target && MyTarget)
						MyTarget = null;
					A_ClearTarget();
					ActiveNode = null;
					isBusy = false;
					SetStateLabel("Spawn");
				}
			}
		
		}
	}
	
	virtual void A_PussyScream()
	{
		int Prob = random[iscream](0,100);
		if (Prob > 78)
		{
			A_StartSound(NPC_Scream, 0 , 1.0, ATTN_NORM, MyVoice);
			
			BlockThingsIterator it;
				
			it = BlockThingsIterator.Create (self, 250);
			
			while (it.Next ()) {
				let next = it.Thing;
				
				if (next is 'NPCCore' && !(next.bKILLED))
				{
					let pp = NPCCore(next);
					if (pp && !pp.isBusy && !pp.isAfterTarget)
					{
						pp.isBusy = true;
						pp.MyTarget = self;
						pp.vel.xy = (0,0);
						pp.G_WTF = true;
						pp.SetStateLabel("Stare");
					}
				}
			}
		}
	}
	
	virtual void A_HostileWalk(int variant)
	{
		switch(variant)
		{
			default:
				Console.Printf("Warning, HostileWalk variant hasn't been set for an NPC!");
				Destroy();
				break;
			case 1:
				A_PostalTarget();
				A_ConcentratedTarget();
				A_Recoil(-0.55);
				A_Chase();
				break;
			case 2:
				A_PostalTarget();
				A_ConcentratedTarget();
				A_Recoil(-0.55);
				A_Chase();
				break;
		}
	}
	
	// Prevents the Doom AI to automatically chase after the Player
	virtual void A_ConcentratedTarget()
	{
		if (MyTarget && !MyTarget.bKILLED)
		{
			target = MyTarget;
		}
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (source != self)
		{	
			if (source is 'PostalDecoration')
			{
				return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
			}
			
			MyTarget = source;
			target = source;
			return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		}
		
		if (inflictor is 'Bulletpuff')
		{
			//Console.Printf("Clip clip clip");
			A_StartSound("hitflesh", CHAN_BODY);
			MyTarget = source;
			target = source;
			return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		}
		
		return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	
	// Mimics Postal 2's weird slow rotation towards it's target
	
	virtual void A_FacePostalTarget()
	{
		float RotationSpeed = 4.5;
		
		if (target)
		{
			if (abs (deltaangle (angle, AngleTo (target))) < 10)
			{
				angle = AngleTo (target);
				return;
			}
			
			if (((AngleTo (target)) - angle + 360) % 360 < 180)
			{	
				A_SetAngle(angle+RotationSpeed, SPF_INTERPOLATE);
			}
			else A_SetAngle(angle-RotationSpeed, SPF_INTERPOLATE);
			
			//Console.Printf("Angle To Target: %f", AngleTo (target));
			//Console.Printf("Angle: %f", angle);
			
		}
		
	}
	
	virtual void A_CheckObstacleTarget()
	{
		// Checks if there's something in the way in front of the target
		// which then the NPC will randomly strafe left or right, probably just like in Postal 2
		
		//Let's get the pitch from A_FaceTarget
		if (target)
			A_FaceTarget(0,0);
		//Console.Printf("Pitch: %d",pitch);
		//Let's check the Distance to the target
		double DistanceTarget = Distance2D(target);
		
		//Create LineTrace
		FLineTraceData lineData;
		LineTrace(angle,DistanceTarget,pitch,offsetz: height-12, data: LineData);
		
		if (LineData.HitType == TRACE_HitActor)
		{
			if (lineData.HitActor != target && !(lineData.HitActor is 'NPCHead'))
			{
				bool ff = random[gogo](0,1);
				
				//Console.Printf("Someone's in my way");
				if (ff)
					Thrust(8, Angle - 90);
				else
					Thrust(8, Angle + 90);
					
				SetStateLabel("HostileChase");
			}
		}
	}
	
	override void Activate(Actor activator)
	{
		if (activator && !isFrozen())
		{
			if (InStateSequence(CurState, ResolveState("Spawn")) || InStateSequence(CurState, ResolveState("Standing")))
			{
				touch(activator);
			}
		}
	}
	
	override void Deactivate(Actor activator)
	{
		if (activator)
		{
			activate(activator);
		}
	}
	
	Default
	{
		//$Category NPCs
		//$Title "Debug Dude"
		//$Sprite DUDEA0
		//$Color 9
		Health 150;
		Radius 12;
		Height 65;
		Speed 0;
		PainChance 256;
		Monster;
		SeeSound "";
		AttackSound "weapons/pistol";
		PainSound "male1/hurt";
		DeathSound "male1/death";
		ActiveSound "";
		Obituary "%o was somehow got killed by a Bystander. What, how is that possible??";
		DropItem "None";
		//+NOTARGETSWITCH;
		+SOLID
		+SHOOTABLE
		-DROPOFF
		-PICKUP
		-NOTDMATCH
		-FRIENDLY
		-SLIDESONWALLS
		-CANPASS
		-CANPUSHWALLS
		-FLOORCLIP
		+WINDTHRUST
		+TELESTOMP
		-NOBLOCKMONST
		//+SPECIAL
		+FORCEPAIN
		+AVOIDMELEE
		+DOHARMSPECIES
		+HARMFRIENDS
		+QUICKTORETALIATE
		+ALLOWPAIN
		-COUNTKILL
		+INTERPOLATEANGLES
		CameraHeight 59;
		
		// We don't need +SPECIAL
		+BUMPSPECIAL
		Activation THINGSPEC_Default | THINGSPEC_Switch | THINGSPEC_ThingActs | THINGSPEC_Activate | THINGSPEC_MonsterTrigger;
		
		// Share the Doom
		NPCCore.debug_hostility D_NONE;
		NPCCore.debug_weapon "none";
		NPCCore.stdObituary "default";
	}
	States
	{
	Petitioning:
		DUDE A 0 { vel.xy = (0,0); }
		DUDE A 0
		{
			isBusy = true;
			if (PetitionNumber != 3)
				PetitionNumber++;
			
			A_FacePostalTarget();
		}
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { A_FacePostalTarget(); target = MyTarget; }
		DUDE ABCDEFGHIJKLMNOP 3 { A_FacePostalTarget(); if (MyTarget) target = MyTarget; }
		PINK A 0 A_StartSound(NPC_PetitionDeny,0);
		PINK ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { A_FacePostalTarget(); if (MyTarget) target = MyTarget; }
		DUDW A 0
		{
			//Clear our target, so we won't be going after it
			isBusy = false;
			Petitioning = false;
			A_ClearTarget();
			MyTarget = null;
		}
		//TNT1 A 0 ACS_Execute(1003,0);
		Goto Spawn;
	Debug:
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3
		{
			angle += 35;
		}
		Loop;
	Spawn:
		DUDW A 0
		{
			if (!target && !MyTarget)
			{
				//isAfterTarget = false;
				//isBusy = false;
			}
			else
			{
				string ttarget = target ? "not null" : "null";
				Console.Printf("NPC Spawn Debug: target is %s", ttarget);
				
				string mmytarget = MyTarget ? "not null" : "null";
				Console.Printf("NPC Spawn Debug: MyTarget is %s", mmytarget);
				if (MyTarget)
				{
					Console.Printf("NPC Spawn Debug: MyTarget pointer is called '%s'", MyTarget.GetClassName());
					
					string mahtarget = MyTarget.bKILLED ? "dead" : "alive";
					Console.Printf("NPC Spawn Debug: MyTarget is %s", mahtarget);
				}
				
				string aftertarget = isAfterTarget ? "true" : "false";
				Console.Printf("NPC Spawn Debug: isAfterTarget is %s", aftertarget);
				
				string busy = isBusy ? "true" : "false";
				Console.Printf("NPC Spawn Debug: isBusy is %s", busy);
				
				string corpsee = hasSeenCorpse ? "true" : "false";
				Console.Printf("NPC Spawn Debug: hasSeenCorpse is %s", corpsee);
				Console.Printf("NPC Spawn Debug: Hostility is '%s'", Hostility);
				Console.Printf("");
			}
			
			if (target)
			{
				string s = string.Format("%s",target.GetClassName());
				Console.Printf("NPC Spawn Debug: I have a target called '%s' ",s);
				
				string selftarget = (target == self) ? "myself" : "another actor";
				Console.Printf("NPC Spawn Debug: The target is '%s'", selftarget);
				
				string targetdead = (target.bKILLED) ? "dead" : "alive";
				Console.Printf("NPC Spawn Debug: My target is '%s'", targetdead);
				
				string targetismytarget = (target == MyTarget) ? "equal" : "not equal";
				Console.Printf("NPC Spawn Debug: target and 'MyTarget' is '%s'", targetismytarget);
				if (MyTarget)
					Console.Printf("NPC Spawn Debug: MyTarget pointer is called '%s'", MyTarget.GetClassName());
					
				if (MyTarget == null)
					Console.Printf("NPC Spawn Debug: MyTarget pointer is null");
				
				string sIsBusy = IsBusy ? "true" : "false";
				Console.Printf("NPC Spawn Debug: IsBusy is '%s'", sIsBusy);
				
				string sATarget = isAfterTarget ? "true" : "false";
				Console.Printf("NPC Spawn Debug: isAfterTarget is '%s'", sATarget);
				
				Console.Printf("NPC Spawn Debug: Hostility is '%s'", Hostility);
				
				string wweapon = (Hostility == "Hostile") ? NPCWeapon : "I don't have a weapon";
				Console.Printf("NPC Spawn Debug: Weapon is '%s'", wweapon);
				
				Console.Printf("NPC Spawn Debug: Health is '%d' (Default: %d)", health, Default.Health);
				Console.Printf("NPC Spawn Debug: pos: %d %d %d",pos.x,pos.y,pos.z);
				Console.Printf("");
			}
			
			A_BystanderNode();
			
		}
		DUDW ABCD 3
		{
			A_PostalWander(flags: CHF_STOPIFBLOCKED);
			if (Petitioning == true)
				SetStateLabel("Petitioning");
			A_BystanderNode();
		}
		//TNT1 A 0 A_BystanderNode();
		DUDW EFGH 3
		{
			A_PostalWander(flags: CHF_STOPIFBLOCKED);
			A_BystanderNode();
		}
		DUDW I 0 A_BystanderThink();
		DUDW IJKL 3
		{
			A_PostalWander(flags: CHF_STOPIFBLOCKED);
			A_BystanderNode();
		}
		//TNT1 A 0 A_BystanderNode();
		DUDW MNOPQR 3
		{
			A_PostalWander(flags: CHF_STOPIFBLOCKED);
			A_BystanderNode();
		}
		Loop;
	See:
		DUDE A 0
		{
			if (target == null)
			{
				if (Hostility ~== "Hostile" || (Hostility ~== "Pussy" && !hasSeenCorpse))
				{
					Console.Printf("NPC See Debug: I have no target");
					isAfterTarget = false;
					A_ClearTarget();
					MyTarget = null;
					SetStateLabel("Spawn");
				}
			}
			else isAfterTarget = true;
			
			if (Hostility == "Pussy" && isAfterTarget == true)
			{
				bFRIGHTENED = true;
				Speed = 2;
				SetStateLabel("PussyChase");
				// todo: find another way to do this correctly
				//A_StartSound(NPC_Scream, CHAN_VOICE, 1.0, ATTN_NORM, MyVoice);
				bNOTARGETSWITCH = true;
				
				A_ConcentratedTarget();
				
			}
				
			if (Hostility == "Hostile" && isAfterTarget == true)
			{
				Speed = 1;
				SetStateLabel("HostileChase");
				
				A_ConcentratedTarget();
				
			}
		}
	See.Plan:
		DUDE A 2
		{
			if (target)
				A_Star();
			else
				SetStateLabel("Spawn");
		}
		Loop;
	FireChase:

		FIRE ABCDEFGHIJ 3
		{
			PainChance = 0;
			A_Recoil(-0.35);
			A_Wander();
			Speed = 2;
		}
		FIRE J 0
		{
			A_PussyScream();
			if (AnnoyingFire == null) SetStateLabel("FireChaseEnd"); Speed = Default.Speed;
		}
		Loop;
	FireChaseEnd:
		SHOO A 0
		{
			// temp fix: spawn dozen of NPCs, kill them instantly, all NPCs will enter this state if they saw them
			
			if (AnnoyingFire == null)
			{
				if (isBusy == true && isAfterTarget == true)
					SetStateLabel("See");
				else
					SetStateLabel("Spawn");
			
			}
		
		}
		SHOO ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO2 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO3 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO4 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		SHO5 ABCDEFGHIJKLMNOPQ 3;
		DUDW A 0 { if (AnnoyingFire) AnnoyingFire.Destroy(); }
		DUDW A 0
		{
			PainChance = Default.PainChance;
			
			if (target != null)
			{
				if (Hostility == "Pussy")
				{
					bFRIGHTENED = true;
					Speed = 2;
					SetStateLabel("PussyChase");
					bNOTARGETSWITCH = true;
				}
				
				if (Hostility == "Hostile" && isAfterTarget == true)
				{
					Speed = 1;
					SetStateLabel("HostileChase");
					
					A_ConcentratedTarget();
				
				}	
			}
			else
				SetStateLabel("Spawn"); Speed = Default.Speed;
		}
		Goto See;
	PussyChase:
		FLEE ABCDEFGHIJ 3
		{
			if (target && MyTarget && MyTarget != target)
			{
				Console.Printf("Done");
				target = MyTarget;
				goal = MyTarget;
			}
			
			/*
			if (target == null)
			{		
				isAfterTarget = false;
				bFRIGHTENED = false;
				Speed = Default.Speed;
				A_ClearTarget();
				MyTarget = null;
				SetStateLabel("Spawn");
			}
			*/
			
			//if (target)
				//A_PostalTarget();
			//A_ConcentratedTarget();
			A_Recoil(-0.85);
			A_PostalChase(null, null, flags: CHF_STOPIFBLOCKED);
		}
		FLEE A 0 A_PussyScream();
		Loop;
	HostileChase:
		TNT1 A 0
		{
			if (target)
				A_ConcentratedTarget();
			Pitch = 0;
			
			if (NPCWeapon ~== "none")
			{
				Hostility = "Pussy";
				SetStateLabel("PussyChase");
				bFRIGHTENED = true;
			}
			
			/* doesn't work, and probably never will
			for(int i = 0; i < WeaponList.Size(); i++)
			{
				if (NPCWeapon ~== WeaponList[i])
				{
					string s = string.Format("HostileChase.%s",WeaponList[i]);
					SetStateLabel(s);
					return;
				}
			}
			*/
			
			
			if (NPCWeapon ~== "Pistol")
				SetStateLabel("HostileChase.Pistol");
			if (NPCWeapon ~== "Shotgun")
				SetStateLabel("HostileChase.Shotgun");
			if (NPCWeapon ~== "RLauncher")
				SetStateLabel("HostileChase.RLauncher");
			
			
		}
	HostileChase.Pistol:
		XXXX A 0 { Pitch = 0; }
		XXXX ABCDEFGHIJKLMNOPQ 2 A_HostileWalk(1);
		XXXX ABCDEFGHIJKLMNOPQ 2 A_HostileWalk(2);
		XXXX A 0 { vel.xy = (0,0); }
		Loop;
	HostileChase.Shotgun:
		SHOT A 0 { Pitch = 0; }
		SHOT ABCDEFGHIJKLMNOPQRSTU 2 A_HostileWalk(1);
		SHOT ABCDEFGHIJKLMNOPQRSTU 2 A_HostileWalk(2);
		SHOT A 0 { vel.xy = (0,0); }
		Loop;
	HostileChase.RLauncher:
		ROCK A 0 { Pitch = 0; }
		ROCK ABCDEFGHIJKLMNOPQRS 2 A_HostileWalk(1);
		ROCK ABCDEFGHIJKLMNOPQRS 2 A_HostileWalk(2);
		ROCK A 0 { vel.xy = (0,0); }
		Loop;
	Missile:
		TNT1 A 0
		{
			if (target)
				A_ConcentratedTarget();
			Pitch = 0;
			A_FaceTarget();
			
			if (Hostility == "Hostile" && isAfterTarget == true)
			{
				if (NPCWeapon == "Pistol")
					SetStateLabel("Missile.Pistol");
				if (NPCWeapon == "Shotgun")
					SetStateLabel("Missile.Shotgun");
				if (NPCWeapon == "RLauncher")
					SetStateLabel("Missile.RLauncher");
			}
		}
	Missile.Pistol:
		XXXF A 0 { vel.xy = (0,0); A_CheckObstacleTarget(); }
		XXXF A 10 A_FaceTarget();
		XXXF A 0 A_PostalTarget();
		XXXF A 6 { A_NPCPistolAttack(); A_FaceTarget(); }
		XXXF A 8;
		XXXF A 0 A_ConcentratedTarget();
		Goto HostileChase.Pistol;
	Missile.Shotgun:
		SHOF A 0 { vel.xy = (0,0); A_CheckObstacleTarget(); }
		SHOF A 10 A_FaceTarget();
		SHOF A 0 A_PostalTarget();
		SHOF A 6 { A_NPCShotgunAttack(); A_FaceTarget(); }
		SHOF A 4;
		SHOF A 0 A_StartSound("weapons/shotgr", CHAN_WEAPON);
		SHOF A 6;
		SHOF A 0 A_ConcentratedTarget();
		Goto HostileChase.Shotgun;
	Missile.RLauncher:
		ROCF A 0 { vel.xy = (0,0); A_CheckObstacleTarget(); }
		ROCF A 10 A_FaceTarget();
		ROCF A 0 A_PostalTarget();
		ROCF A 6
		{
			A_FaceTarget();
			
			class<actor> Rocket = "PostalRocket";
			Actor pp = SpawnMissileXYZ (pos+(0,0,45), target, Rocket, self);
			
			if (pp)
			{
				let p2 = PostalRocket(pp);
				if (p2 && target)
				{
					p2.Speed = 10;
					p2.AddedTime = 666;
					P2.Tracer = target;
					p2.SeekingTarget = target;
					p2.Owner = self;
					p2.Pitch = self.pitch;
					p2.Angle = self.angle;
					p2.Seeking = true;
				}
			}
		}
		ROCF A 4;
		ROCF A 6;
		ROCF A 0 A_ConcentratedTarget();
		Goto HostileChase.RLauncher;
	Pain:
		DUDE A 0 { if (gotPissedOn == true) { isAfterTarget = false; SetStateLabel("Debug"); }}
		DUDE A 0 { isBusy = false; }
		DUDE A 3 A_Pain;
		DUDE A 0 { return ResolveState("See"); }
	Bumping:
		DUDE A 0 A_StartSound(NPC_Bump, CHAN_VOICE, 1.0, ATTN_NORM, MyVoice);
		DUDE A 0 { vel.xy = (0,0); }
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { if (MyTarget) target = MyTarget; A_FacePostalTarget(); }
		
		DUDW A 0
		{
			//Clear our target, so we won't be going after it
			isBusy = false;
			A_ClearTarget();
			MyTarget = null;
			
			//Before eventually going back to Spawn, let's check our surroundings
			A_BystanderThink();
		}
		Goto Spawn;
	Stare:
		DUDE A 0 
		{ 
			vel.xy = (0,0);
			
			if (G_WTF)
			{
				A_StartSound(NPC_Reaction, CHAN_VOICE, 1.0, ATTN_NORM, MyVoice);
			}
		}
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { if (MyTarget) target = MyTarget; A_FacePostalTarget(); }
		
		DUDW A 0
		{
			if (G_WTF)
			{
				// loop one more time
				SetStateLabel("Stare");
				G_WTF = false;
				return;
			}
			
			if (G_GotTauntedAt)
			{
				// todo: Implement "You got a problem huh??" state in else statement
				bool laugh = random[lgh](0,1);
				if (laugh)
				{
					SetStateLabel("Laughing");
					G_GotTauntedAt = false;
					return;
				}
				else
				{
					bool retaliate = random[rtlt](0,1);
					if (!retaliate)
					{
						// Do nothing if it's false
						
						isBusy = false;
						A_ClearTarget();
						MyTarget = null;
						A_BystanderThink();
						G_GotTauntedAt = false;
						return;
					}
					
					// todo: here
					// We won't laugh at the Player, so what do we do? Flee, retaliate?
					SetStateLabel("See");
					G_GotTauntedAt = false;
					return;
				}
			}
			
			//Clear our target, so we won't be going after it
			isBusy = false;
			A_ClearTarget();
			MyTarget = null;
			
			//Before eventually going back to Spawn, let's check our surroundings
			A_BystanderThink();
		}
		Goto Spawn;
	Laughing:
		LAUG A 0 A_StartSound(NPC_Laugh, CHAN_VOICE);
		LAUG ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { if (MyTarget) target = MyTarget; }
		LAU2 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { if (MyTarget) target = MyTarget; }
		LAU3 ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { if (MyTarget) target = MyTarget; }
		LAU4 ABCDEFGHIJKLM 3 { if (MyTarget) target = MyTarget; }
		LAU4 M 0
		{
			//Clear our target, so we won't be going after it
			isBusy = false;
			A_ClearTarget();
			MyTarget = null;
			
			//Before eventually going back to Spawn, let's check our surroundings
			A_BystanderThink();
		}
		Goto Spawn;
	Standing:
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3;
		DUDE A 0
		{
			A_BystanderNode();
		}
		Loop;
	DickOut:
		DUDE A 0 A_StartSound(NPC_Dickout, CHAN_VOICE, 1.0, ATTN_NORM, MyVoice);
		DUDE A 0 { vel.xy = (0,0); }
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { target = MyTarget; A_FacePostalTarget(); }
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 2 { target = MyTarget; A_FacePostalTarget(); }
		
		DUDW A 0
		{
			//our target is the Player always in this state
			let PlayerDude = PostalDude(target);
			
			if (PlayerDude)
			{
				//Check if Player's onscreen weapon is Urethra, pretty self explanatory
				if (PlayerDude.Player.ReadyWeapon == PlayerDude.PlayerData.UrethraWeapon)
				{
					isBusy = false;
					A_ClearTarget();
					MyTarget = null;
					SetStateLabel("Spawn");
				}
				else
				{
					isBusy = false;
					A_ClearTarget();
					MyTarget = null;
				}
			}
			//Although this may never happen (or can if the Player suddenly zipped it's pants), we don't want to make nasty mistakes.
			isBusy = false;
		}
		Goto Spawn;
	StaringWeapon:
		DUDE A 0 
		{ 
			vel.xy = (0,0);
			if (Hostility ~== "Pussy")
				A_StartSound(NPC_Panic, 0 , 1.0, ATTN_NORM, MyVoice);
		}
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { target = MyTarget; A_FacePostalTarget(); }
		//Be hostile, or flee from the frightening Player
		DUDE A 0 { isAfterTarget = true; if (Hostility ~== "Hostile") A_StartSound(NPC_Taunt, 0, 1.0, ATTN_NORM, MyVoice); }
		DUDE A 0
		{
			if (Hostility == "Pussy")
				angle = -angle;
		}
		Goto See;
	StaringNPC:
		DUDE A 0 { vel.xy = (0,0); }
		
		DUDE A 0 
		{	
			let pp = NPCCore(MyTarget);
			
			//If the Unique ID attached to the corpse is the same in our deadpeople array, then forget about it
			//If this is the first time then just assign the element of deadpeople to the corpse's element
			//so the NPC will always ignore it, that is if it's a Hostile-type NPC
			
			if (pp)
			{
			
				if (deadpeople[pp.UniqueID] == pp.UniqueID && Hostility == "Hostile")
				{
					SetStateLabel("Spawn");
					isBusy = false;
					return;
				}
				else
				{
					deadpeople[pp.UniqueID] = pp.UniqueID;
					hasSeenCorpse = true;
				}
			}
			
			
		}
		DUDE ABCDEFGHIJKLMNOPQRSTUVWXYZ 3 { target = MyTarget; A_FacePostalTarget(); }
		TNT1 A 0 
		{
			//Grab the target's variables
			let pp = NPCCore(target);
			//Console.Printf("NPCCore let pp");
			
			if (pp)
			{
				//If the NPC's (not target's) Hostility is 0
				if (isBusy == true)
				{
					if (target is 'NPCCore')
					{
						//Console.Printf("Hostility 0 yada yada");
						//If target's Hostility is 2 (Hostile)
						let pp = NPCCore(target);
						
						if (pp)
						{
							if (pp.Hostility ~== "Hostile")
							{
								let pp = NPCCore(target);
								if (Hostility ~== "Hostile")
								{
									target = pp;
									MyTarget = pp;
									isBusy = false;
									A_StartSound(NPC_Taunt, 0 ,1.0, ATTN_NORM, MyVoice);
									isAfterTarget = true;
									SetStateLabel("See");
									return;
								}
								
								if (Hostility ~== "Pussy")
								{
									target = pp;
									MyTarget = pp;
									isBusy = false;
									A_StartSound(NPC_Panic, 0 , 1.0, ATTN_NORM, MyVoice);
									isAfterTarget = true;
									SetStateLabel("See");
									angle = -angle;
									return;
								}
							}
						}
					}
					
					//todo: Add a StaringCorpse state
					if (target is 'NPCCore' && Hostility == "Pussy" && target.bCORPSE)
					{
						target = pp;
						MyTarget = pp;
						isBusy = false;
						isAfterTarget = true;
						SetStateLabel("See");
						angle = -angle;
					}
					
				}
			}
		}
		Goto See;
	Death:
		DUDD A 0 
		{
			A_Scream();
			
			if (NPCWeapon ~== "Hands")
				return;
			
			for(int i = 0; i < WeaponList.Size(); i++)
			{
				if (NPCWeapon ~== WeaponList[i])
				{
					vector3 droploc = (pos.x+random[tr](0,35), pos.y+random[rr](0,35), pos.z+50);
					string DroppedWeapon = string.Format("Post%s",WeaponList[i]);
					class<actor> dropthisweapon = DroppedWeapon;
					let WeaponOnTheGround = spawn(dropthisweapon, droploc);
					if (WeaponOnTheGround)
					{
						WeaponOnTheGround.Angle = random[rangle](-360,360);
					}
					
					return;
				}
			}
			
		}
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 1;
		DUD2 A 0 A_NoBlocking;
		DUD2 AB 2;
		DUD2 C 2 A_PlaySound("bodyfall");
		DUD2 DEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	Headless.Death:
		XYXY A 0 
		{
			A_Scream();
		}
		XYXY ABCDEFGHIJKLMNOPQRSTUVWXYZ 1;
		XYX2 A 0 A_NoBlocking;
		XYX2 ABCDEFGHIJKLMNOP 2;
		XYX2 P -1;
		Stop;
	XDeath:
		DUDD ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
		DUD2 A 0 A_NoBlocking;
		DUD2 ABCDEFGHIJKLMNOP 2;
		DUD2 P -1;
		Stop;
	Raise:
		Stop;
	}
}

extend class NPCCore
{
	// List of weapons NPCs don't like seeing from the Player
	// Gets checked when NPCs are being bumped, or seeing
	static const string DangerList[] =
	{
		"PostCowhead",
		"PostGrenade",
		"PostM16",
		"PostMolotov",
		"PostNapalmLauncher",
		"PostPistol",
		"PostRLauncher",
		"PostScissors",
		"PostScythe",
		"PostShotgun",
		"PostRifle",
		"PostUrethra",
		"PostWMD"
	};
	
	// NPCs will keep distance if the Player has the following weapons equipped
	// Player version
	static const string Player_DistanceList[] =
	{
		"PostCowhead",
		"PostGrenade",
		"PostMolotov",
		"PostNapalmLauncher",
		"PostRLauncher",
		"PostShotgun",
		"PostWMD"
	};
	
	// NPCs will keep distance if the NPC has the following weapons equipped
	// NPC version
	static const string NPC_DistanceList[] =
	{
		"Cowhead",
		"Grenade",
		"Molotov",
		"NapalmLauncher",
		"RLauncher",
		"Shotgun",
		"WMD"
	};
	
	//////////////////////////////////
	/////// Bump/Touch feature
	//////////////////////////////////
	
	override void Touch(Actor toucher)
	{
		if (toucher)
		{
			if (toucher is 'PostalDude')
			{
				let PlayerDude = PostalDude(toucher);
				
				// Let's check if there's Fire attached on the Player...
				if (PlayerDude.MyAnnoyingFire != null && PlayerDude)
				{
					class<actor> Fire = "PostalFire";
					actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
					
					// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
					// but make sure to check it's not null or else GZDoom will crash
					if (AttachedFire)
					{
						let dd = PostalFire(AttachedFire);
						if (dd)
						{
							dd.Owner = self;
							dd.ThisOneHurts = true;
							dd.Counter = 0;
						}
						
						if (AnnoyingFire != null)
						{
							//There's not enough time for the newly spawned Fire to cause damage
							AttachedFire.Destroy();
							
							if (dd)
								dd.TimeBeforeDisappearing = level.time + (35 * 12);
						}
						else
							AnnoyingFire = AttachedFire;
					}
				}
				
				
				if (PlayerDude.MyAnnoyingFire == null && AnnoyingFire != null && PlayerDude)
				{
					//woah dude you don't have a fire on you? Let me help you!
					
					if (PlayerDude.PlayerData.P_GodMode != true && PlayerDude.PlayerData)
					{
					
						Console.Printf("Dude doesn't have fire");
						
						class<actor> Fire = "PostalFire";
						actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
						
						// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
						// but make sure to check it's not null or else GZDoom will crash
						if (AttachedFire)
						{
							let dd = PostalFire(AttachedFire);
							if (dd)
							{
								dd.Owner = PlayerDude;
								dd.ThisOneHurts = true;
								dd.Counter = 0;
							}
							
							if (PlayerDude.MyAnnoyingFire != null)
							{
								//There's not enough time for the newly spawned Fire to cause damage
								AttachedFire.Destroy();
								
								if (dd)
									dd.TimeBeforeDisappearing = level.time + (35 * 12);
							}
							else
								PlayerDude.MyAnnoyingFire = AttachedFire;
						}
					}
				}
				
				
			}
				//Note: This could have been in toucher.NPCCore aswell, but since we are aiming for the Fire to be kinda "universal"
				//I put it here - who knows maybe in the future I'll figure out how can I make the Fire attach to any custom monster without
				//relying on PostalActor
				if (toucher is 'PostalActor')
				{	
						let asd = PostalActor(toucher);
						
						
						if (asd.AnnoyingFire != null && asd)
						{
							class<actor> Fire = "PostalFire";
							actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
							
							// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
							// but make sure to check it's not null or else GZDoom will crash
							if (AttachedFire)
							{
								let dd = PostalFire(AttachedFire);
								if (dd)
								{
									dd.Owner = self;
									dd.ThisOneHurts = true;
									dd.Counter = 0;
								}
								
								if (AnnoyingFire != null)
								{
									//There's not enough time for the newly spawned Fire to cause damage
									AttachedFire.Destroy();
									
									if (dd)
										dd.TimeBeforeDisappearing = level.time + (35 * 12);
								}
								else
									AnnoyingFire = AttachedFire;
							}
							
							//Let's exit anyway
							return;
						}
						
						
						if (asd.AnnoyingFire == null && AnnoyingFire != null)
						{
							class<actor> Fire = "PostalFire";
							actor AttachedFire = spawn(Fire, toucher.pos, ALLOW_REPLACE);
							
							// Set the corpse's angle with the PostalCatInv's angle before it disappears/gets replaced, 
							// but make sure to check it's not null or else GZDoom will crash
							if (AttachedFire)
							{
								let dd = PostalFire(AttachedFire);
								if (dd)
								{
									dd.Owner = asd;
									dd.ThisOneHurts = true;
									dd.Counter = 0;
								}
								
								if (AnnoyingFire != null)
								{
									//There's not enough time for the newly spawned Fire to cause damage
									AttachedFire.Destroy();
									
									if (dd)
										dd.TimeBeforeDisappearing = level.time + (35 * 12);
								}
								else
									asd.AnnoyingFire = AttachedFire;
							}
							
							return;
						}
				
				}
			
			
			//If we aren't staring, nor we have more than 0 HP, or we aren't hostile atm, do:
			//Checking for 0 HP is needed because we don't want to resurrect dead NPCs into Ghost ones that are unkillable
			
			if (isAfterTarget != true && health > 0 && isBusy != true)
			{
				// If the target is Postal Dude, do this
				if (toucher is 'PostalDude' && isAfterTarget != true)
				{
					let PlayerDude = PostalDude(toucher);
					bool dangerousWeapon;
					
					if (PlayerDude != PlayerDude.Player.mo) return;
					if (PlayerDude == null) return;
					
					if (isAfterTarget == false)
					{
						for (int i = 0; i < DangerList.Size()-1; i++)
						{
							if (PlayerDude.Player.ReadyWeapon is DangerList[i] || user_attacksplayeronsight == true)
							{
								if (Hostility == "Hostile")
								{
									target = PlayerDude;
									MyTarget = PlayerDude;
									isAfterTarget = true;
									A_StartSound(NPC_Taunt,0 , 1.0, ATTN_NORM, MyVoice);
									SetStateLabel("HostileChase");
									return;
								}
								
								if (Hostility == "Pussy")
								{
									target = PlayerDude;
									MyTarget = PlayerDude;
									isAfterTarget = true;
									A_StartSound(NPC_Panic,0 , 1.0, ATTN_NORM, MyVoice);
									SetStateLabel("See");
									return;
								}
							}
						}
						
						target = PlayerDude;
						MyTarget = PlayerDude;
						A_FacePostalTarget();
						isBusy = true;
						SetStateLabel("Bumping");
					}
				}
				
				if (toucher is 'PlayerPawn' && isAfterTarget != true && !(toucher is 'PostalDude'))
				{
					target = toucher;
					MyTarget = toucher;
					A_FacePostalTarget();
					isBusy = true;
					SetStateLabel("Bumping");
					return;
				}
				
				// If our target is another NPCCore, then do the following
				if (toucher is 'NPCCore' && isAfterTarget != true)
				{
					let pp = NPCCore(toucher);
					//If we aren't Hostile or Fleeing, do:
					//Calm, normal wandering/walking
					
					if (pp == null) return;
					
					if (pp.isAfterTarget == false)
					{
						if (StopGoingAfterNode != true)
						{
							NodeCooldown = level.time;
							StopGoingAfterNode = true;
							ActiveNode = null;
						}
						
						return;
					}
					
					if (pp.isAfterTarget == true)
					{
						//Fleeing, running around and screaming like hell
						if (pp.Hostility == "Pussy" && pp.isAfterTarget == true)
						{
							//Console.Printf("STOP RUNNING INTO ME YOU SCREAMING PUSSY");
							A_FacePostalTarget();
							target = pp;
							MyTarget = pp;
							isBusy = true;
							SetStateLabel("Bumping");
							return;
						}
						
						//Hostile, attacks the target
						//If we aren't fleeing or Hostile, do:
						if (pp.Hostility == "Hostile" && pp.isAfterTarget == true)
						{
							//Console.Printf("HE'S GOT A GUN!!!");
							if (Hostility == "Hostile")
							{
								target = pp;
								MyTarget = pp;
								isAfterTarget = true;
								A_StartSound(NPC_Taunt,0 , 1.0, ATTN_NORM, MyVoice);
								SetStateLabel("HostileChase");
								return;
							}
							
							if (Hostility == "Pussy")
							{
								isAfterTarget = true;
								target = pp;
								MyTarget = pp;
								A_StartSound(NPC_Panic,0 , 1.0, ATTN_NORM, MyVoice);
								SetStateLabel("See");
								return;
							}
						}
					}
				}
				
				
				if ((toucher is 'Champ'  || toucher is 'PostalCatInv') && isAfterTarget != true)
				{
					SetStateLabel("Spawn");
					return;
				}
				
				
				if (toucher is 'CowMike' && isAfterTarget != true)
				{			
					if (Hostility == "Hostile")
					{
						target = toucher;
						MyTarget = toucher;
						isAfterTarget = true;
						A_StartSound(NPC_Taunt, 0 , 1.0, ATTN_NORM, MyVoice);
						SetStateLabel("HostileChase");
						return;
					}
					
					if (Hostility == "Pussy")
					{
						isAfterTarget = true;
						target = toucher;
						MyTarget = toucher;
						A_StartSound(NPC_Panic, 0 , 1.0, ATTN_NORM, MyVoice);
						SetStateLabel("See");
						return;
					}
				}
				
				
			}
		}	
	}
	
	//////////////////////////////////
	/////// "See" logic
	//////////////////////////////////
	
	action void A_BystanderThink()
	{
		//many thanks to phantombeta!!
		
		double fov = 90; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, 400); // The number here is (possibly roughly) the maximum distance they can see
		Actor unknownentity;
		
		if (invoker.isAfterTarget)
		{
			string ttarget = target ? "exists" : "is null";
			Console.Printf("Warning: 'isAfterTarget' is true, while target '%s' | warp: %d %d %d",ttarget,pos.x,pos.y,pos.z);
			return;
		}
		
		while (it.Next () && it.Thing != null) {
				let next = it.Thing;
				
			
			if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) continue;
			
			if (!CheckSight (next, SF_SeePastShootableLines)) continue;
			
			

			// Do things with the "next" pointer here
			
				if (invoker.isAfterTarget != true)
				{
					if (next is 'PostalDude' && !(next.bKILLED))
					{
						let PlayerDude = PostalDude(next);
						if (PlayerDude && PlayerDude.Player.mo && PlayerDude.player.ReadyWeapon != null && PlayerDude == PlayerDude.Player.mo)
						{
							if (PlayerDude.Player.ReadyWeapon == Weapon(PlayerDude.FindInventory("PostUrethra")))
							{
								//A_PlaySound("grunt/sight",0);
								invoker.isBusy = true;
								invoker.MyTarget = PlayerDude;
								vel.xy = (0,0);
								SetStateLabel("DickOut");
								return;
							}
							
							for (int i = 0; i < invoker.DangerList.Size()-1; i++)
							{
								if (PlayerDude.Player.ReadyWeapon is invoker.DangerList[i] || invoker.user_attacksplayeronsight == true)
								{
									invoker.isBusy = true;
									invoker.MyTarget = PlayerDude;
									vel.xy = (0,0);
									SetStateLabel("StaringWeapon");
									return;
								}
							}
						}
					}
					
					
					if (next is 'NPCCore' && next != self)
					{
						let pp = NPCCore(next);
						if (pp.bCORPSE && pp)
						{
							if (!(invoker.deadpeople[pp.UniqueID] == pp.UniqueID))
							{
								//invoker.staringAt = next;
								invoker.isBusy = true;
								invoker.MyTarget = next;
								target = next;
								vel.xy = (0,0);
								SetStateLabel("StaringNPC");
								return;
							}
						}
						
						
						if (pp.Hostility == "Hostile" && pp.isAfterTarget == true && !pp.bKILLED && pp)
						{
							//Console.Printf("I see NPCCore");
							//invoker.staringAt = next;
							invoker.isBusy = true;
							if (invoker.user_attacksplayeronsight != true)
							{
								invoker.MyTarget = next;
								target = next;
								vel.xy = (0,0);
								SetStateLabel("StaringNPC");
								return;
							}
							else
							{
								if (pp.target is 'PostalDude' || pp.MyTarget is 'PostalDude')
								{
									target = next.target;
									invoker.MyTarget = next.target;
									return;
								}
							}
						}
					}
					
					if (next is 'PostalActor' || next is 'PostalDecoration')
					{
						if (next is "PostalDecoration") return;
						
						let pa = PostalActor(next);
						if (pa && pa.STD_NeverTarget == true) return;
					}
					
					if (next.bIsMonster && !(next.bKILLED) && !(next is 'NPCCore') && !(next is 'Champ') && !(next is 'PostalCatInv') && !(next is 'PostalLiquidGas') && !(next is 'PostalFire') && !(next is 'PouringGas') 
					&& !(next is 'RandomPostalFire') && !(next is 'FireParticleBottom') && !(next is 'FireSmokeUp') && !(next is 'PostalDoor') && !(next is 'PostalDoor_Extender'))
					{
						invoker.isAfterTarget = true;
						if (invoker.Hostility ~== "Hostile")
							A_StartSound(invoker.NPC_Taunt,0 , 1.0, ATTN_NORM, invoker.MyVoice);
						else if (invoker.Hostility ~== "Pussy")
							A_StartSound(invoker.NPC_Panic,0 , 1.0, ATTN_NORM, invoker.MyVoice);
							
						invoker.MyTarget = next;
						target = next;
						vel.xy = (0,0);
						SetStateLabel("See");
						return;
					}
					
					
					if (next is 'CowMike' && !next.bKILLED)
					{
						Actor madcow = next;
						if (invoker.Hostility == "Hostile")
						{
							invoker.isAfterTarget = true;
							A_StartSound(invoker.NPC_Taunt,0 , 1.0, ATTN_NORM, invoker.MyVoice);
							invoker.MyTarget = madcow;
							vel.xy = (0,0);
							SetStateLabel("See");
							return;
						}
						
						
						if (invoker.Hostility == "Pussy")
						{
							invoker.isAfterTarget = true;
							A_StartSound(invoker.NPC_Panic,0 ,1.0, ATTN_NORM, invoker.MyVoice);
							invoker.MyTarget = madcow;
							vel.xy = (0,0);
							SetStateLabel("See");
							return;
						}
					}
					
					
				}
			}
    }
	
	action void A_NPCPistolAttack()
	{
		if (target)
		{
			vel.xy = (0,0);
			invoker.A_FacePostalTarget();
			double ang = angle;
			double slope = AimLineAttack(ang, MISSILERANGE);
			A_StartSound("weapons/pistol", CHAN_WEAPON);
			//ang  += Random2[PosAttack]() * (22.5/256);
			int damage = Random[PosAttack](1, 5) * 3;
			LineAttack(ang, MISSILERANGE, slope, damage, "Hitscan", "Bulletpuff", 0, null, 30, 0.5);
		}
	}
	
	action void A_NPCShotgunAttack()
	{
		if (target)
		{
			vel.xy = (0,0);
			invoker.A_FacePostalTarget();
			double bangle = angle;
			double slope = AimLineAttack(bangle, MISSILERANGE);
			
			A_StartSound("weapons/shotgf", CHAN_WEAPON);
			
			for (int i=0 ; i<3 ; i++)
			{
				double ang = bangle; // + Random2[SPosAttack]() * (22.5/256);
				int damage = Random[SPosAttack](1, 5) * 3;
				LineAttack(ang, MISSILERANGE, slope, damage, "Hitscan", "Bulletpuff", 0, null, 30, 0.5);
			}
		}
    }
	
	action void A_BystanderNode()
	{
		//many thanks to phantombeta!!
		double fov = 160; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, 512); // The number here is (possibly roughly) the maximum distance they can see
		
		while (it.Next ()) {
				let next = it.Thing;
				
				//if (!next.bShootable) // || next.bKilled || next.health < 1)
				//{
				//	continue;
				//}
				
				
				if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
				{
					continue;
				}
				
				
				if (!CheckSight (next, SF_SeePastShootableLines)) // Not in sight
					continue;
				
				if (invoker.ActiveNode == null)
				{
					if (next is 'Postal_Node' && next)
					{
						//double diff = deltaangle(angle, AngleTo(next));
						//double delta = abs(diff);
						
						invoker.ActiveNode = next;
						//Angle += AngleTo(next);
						//Console.Printf("I see a Postal_Node.");
						return;
					}
				}
			}
    }
}