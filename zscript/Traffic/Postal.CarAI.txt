class PostalCar : PostalActor
{
	void A_CarNode()
	{
		if (ActiveNode) return;
		
		BlockThingsIterator it = BlockThingsIterator.Create (self, 1000); // The number here is (possibly roughly) the maximum distance they can see
		double fov = 160;
		
		while (it.Next ()) {
				let next = it.Thing;
				if (!next) return;
				
				if (!user_PatrolNextTag || PatrolSearchFailed)
				{
					if (ActiveNode == null)
					{
						if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
							continue;
						
						if (next is 'Postal_CarNode')
						{
							ActiveNode = next;
							Angle = AngleTo(ActiveNode);
						}
					}
					
					return;
				}
				
				if (ActiveNode == null)
				{
					if (next is 'Postal_CarNode')
					{	
						let node = Postal_CarNode(next);
						
						if (node.user_PatrolTag == user_PatrolNextTag && node)
						{
							ActiveNode = node;
							Angle = AngleTo(ActiveNode);
						}
					}
				}
				
			}
    }
	
	Actor ActiveNode;
	double HonkTime;
	
	int user_PatrolNextTag;
	bool PatrolSearchFailed;
	
	int WarningTime;
	
	override void Tick()
	{
		Super.Tick();
		
		AlignToPlane(self, 0);
		
		if (!ActiveNode && WarningTime < level.time && !PatrolSearchFailed && user_PatrolNextTag)
		{
			Console.Printf("Debug: Car couldn't find patrolpoint %d", user_PatrolNextTag);
			Console.Printf("Debug: Car will now latch onto a nearby node...");
			Console.Printf("Debug: Warp: %d %d %d", pos.x, pos.y, pos.z);
			Console.Printf("");
			PatrolSearchFailed = true;
			A_CarNode();
		}
		
		if (ActiveNode != null)
		{
			// Here's a little lesson in trickery...
			Vector3 norm = CurSector.floorPlane.normal;
			if (!(norm ~== (0,0,1)))
			{
				bFLOORHUGGER = true;
			}
			else bFLOORHUGGER = false;
			
			target = ActiveNode;
			double i = -20;
			while (i <= 20)
			{
				FLineTraceData lineData;
				LineTrace(angle+i,250, 0, data: LineData);
				
				if (LineData.HitType == TRACE_HitActor)
				{
					if (level.time > HonkTime)
					{
						A_StartSound("carhorn", CHAN_BODY, CHANF_OVERLAP);
						HonkTime = level.time + 35 * frandom(0,3);
					}
					return;
				}
				i++;
			}
			
			A_StartSound("carengine", CHAN_BODY, CHANF_NOSTOP);
			
			if (!ActiveNode) return;
			
			if (Distance2D(ActiveNode) >= 155)
			{
				if (abs (deltaangle (angle, AngleTo (ActiveNode))) < 7)
				{
					angle = AngleTo (ActiveNode);
				}
				
				if (((AngleTo (ActiveNode)) - angle + 360) % 360 < 180)
				{	
					A_SetAngle(angle+4, SPF_INTERPOLATE);
				}
				else A_SetAngle(angle-4, SPF_INTERPOLATE);
			}
			
			A_Recoil(-0.45);
			
			for (double j = 75; j < 100; j += 1)
			{
				if (ActiveNode == null) break;
				
				if ((Distance2D(ActiveNode) <= j || Distance2D(ActiveNode) ~== j) && ActiveNode != null)
				{
					double SavedAngle = angle;
					
					let node = Postal_CarNode(ActiveNode);
					if (node.NextNode != null && node)
					{
						ActiveNode = node.NextNode;
						break;
					}
					else
						ActiveNode = null;
					
					Console.Printf("train null");
				}
			}
		}
	
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		STD_NeverTarget = true;
		STD_NoKillLine = true;
		
		WarningTime = level.time + 35 * 5;
	
	}
	
	Default
	{
		//$Category Traffic
		//$Title "Car Debug"
		Radius 70;
		Height 55;
		Speed 1;
		Mass 999999999;
		Health 999999;
		Monster;
		Obituary "Next time %k should stop hugging cars";
		+SOLID
		+SPECTRAL
		+ROLLSPRITE
		+ABSMASKPITCH
		+ABSMASKANGLE
		+DROPOFF
		+CANPASS
		+SLIDESONWALLS
		-NOBLOCKMAP
	}
	States
	{
	Spawn:
		PROP A 3
		{
			A_CarNode();
		}
		Loop;
	See:
		TNT1 A 0;
		Goto Spawn;
	Pain:
		TNT1 A 0;
		Goto Spawn;
	Death:
		TNT1 A 0;
		Stop;
	}
}

//////////////////////////////////////////////
//////////////////////////////////////////////
//// Train node
//////////////////////////////////////////////
//////////////////////////////////////////////

class Postal_CarNode : PostalActor
{
	Actor NextNode, PreviousNode;
	
	int WarningTime;
	bool SpawnedMark;
	
	// mimics ZDoom's patrol points
	int user_PatrolTag, user_PatrolNextTag;
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		WarningTime = level.time + 35 * 5;
		
		if (!user_PatrolTag)
		{
			Console.Printf("Warning: Node's patroltag hasn't been set! Destroying.. (warp %d %d %d)", pos.x, pos.y, pos.z);
			spawn("Postal_FailedPathnode", self.pos+(0,0,50), ALLOW_REPLACE);
			Destroy();
			return;
		}
		
		if (!user_PatrolNextTag)
		{
			Console.Printf("Warning: Node's next patroltag hasn't been set! Destroying.. (warp %d %d %d)", pos.x, pos.y, pos.z);
			spawn("Postal_FailedPathnode", self.pos+(0,0,50), ALLOW_REPLACE);
			Destroy();
			return;
		}
	
	}
	
	override void Tick()
	{
		Super.Tick();
		
		//All nodes should be able to find their next nodes under 10 seconds
		if (WarningTime < level.time)
		{
			if (NextNode == null)
			{
				if (SpawnedMark != true)
				{
					Console.Printf("Debug: Node %d can't find next patrolpoint %d", user_PatrolTag, user_PatrolNextTag);
					if (PreviousNode == null)
						Console.Printf("Debug: Node %d 's next patrolpoint is now itself.", user_PatrolTag);
					else
						Console.Printf("Debug: Node %d 's next patrolpoint is now the previous node.", user_PatrolTag);
					
					Console.Printf("Debug: Warp: %d %d %d", pos.x, pos.y, pos.z);
					Console.Printf("");
					spawn("Postal_FailedPathnode", self.pos+(0,0,50), ALLOW_REPLACE);
					if (PreviousNode != null)
						NextNode = PreviousNode;
					else
						NextNode = self;
						
					SpawnedMark = true;
				}
				
			}
		}
	}
	
	Default
	{
		//$Category Traffic
		//$Title "Car Pathnode"
		//$Sprite ZCARA0
		+NOGRAVITY;
		-SOLID;
		Radius 25;
		Height 25;
	}
	States
	{
	Spawn:
		TNT1 A 5
		{
			//Check if the NextNode actor pointer is null
			//Continously creating an iterator will degrade performance
			if (NextNode == null)
				A_SetNextNode();
		
		}
		Loop;
	}
	
	//It is sensitive to angle, so If you are placing them on a map make sure they are facing a node
	void A_SetNextNode()
	{
		if (!user_PatrolTag || !user_PatrolNextTag || SpawnedMark || NextNode) return;
		
		//many thanks to phantombeta!!
		double fov = 50; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, 10000); // 1024
		
		while (it.Next ()) {
				let next = it.Thing;
				if (!next) return;
				
				if (NextNode == null)
				{
					//Hopefully by the time the NPC approaches it's node it will already attach an actor pointer;
					if (next is 'Postal_CarNode' && next != self)
					{
							let node = Postal_CarNode(next);
							
							if (node.user_PatrolTag == user_PatrolNextTag && node)
								NextNode = node;
							
							node.PreviousNode = self;
					}
				}
						
			}
    }
}