class PostalCar : PostalActor
{
	action void A_CarNode()
	{
		//many thanks to phantombeta!!
		double fov = 160; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, 756); // The number here is (possibly roughly) the maximum distance they can see
		
		while (it.Next ()) {
				let next = it.Thing;
				if (next == null) return;
				
				
				if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
					continue;
				
				if (invoker.ActiveNode == null)
				{
					if (next is 'Postal_CarNode')
					{
						invoker.ActiveNode = next;
						Angle = AngleTo(invoker.ActiveNode);
					}
				}
						
			}
    }
	
	Actor ActiveNode;
	double HonkTime;
	
	override void Tick()
	{
		Super.Tick();
		
		AlignToPlane(self, 0);
		
		if (ActiveNode != null)
		{
			// Here's a little lesson in trickery...
			Vector3 norm = CurSector.floorPlane.normal;
			if (!(norm ~== (0,0,1)))
			{
				bFLOORHUGGER = true;
			}
			else bFLOORHUGGER = false;
			
			target = ActiveNode;
			double i = -20;
			while (i <= 20)
			{
				FLineTraceData lineData;
				LineTrace(angle+i,250, 0, data: LineData);
				
				if (LineData.HitType == TRACE_HitActor)
				{
					if (level.time > HonkTime)
					{
						A_StartSound("carhorn", CHAN_BODY, CHANF_OVERLAP);
						HonkTime = level.time + 35 * frandom(0,3);
					}
					return;
				}
				i++;
			}
			
			A_StartSound("carengine", CHAN_BODY, CHANF_NOSTOP);
			
			if (!ActiveNode) return;
			
			if (Distance2D(ActiveNode) >= 155)
			{
				if (abs (deltaangle (angle, AngleTo (ActiveNode))) < 7)
				{
					angle = AngleTo (ActiveNode);
				}
				
				if (((AngleTo (ActiveNode)) - angle + 360) % 360 < 180)
				{	
					A_SetAngle(angle+4, SPF_INTERPOLATE);
				}
				else A_SetAngle(angle-4, SPF_INTERPOLATE);
			}
			
			A_Recoil(-0.45);
			
			for (double j = 75; j < 100; j += 1)
			{
				if (ActiveNode == null) break;
				
				if ((Distance2D(ActiveNode) <= j || Distance2D(ActiveNode) ~== j) && ActiveNode != null)
				{
					double SavedAngle = angle;
					
					let node = Postal_CarNode(ActiveNode);
					if (node.NextNode != null && node)
					{
						ActiveNode = node.NextNode;
						break;
					}
					else
						ActiveNode = null;
					
					Console.Printf("train null");
				}
			}
		}
	
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		STD_NeverTarget = true;
		STD_NoKillLine = true;
	
	}
	
	Default
	{
		//$Category Traffic
		//$Title "Car Debug"
		Radius 70;
		Height 55;
		Speed 1;
		Mass 999999999;
		Health 999999;
		Monster;
		Obituary "Next time %k should stop hugging cars";
		+SOLID
		+SPECTRAL
		+ROLLSPRITE
		+ABSMASKPITCH
		+ABSMASKANGLE
		+DROPOFF
		+CANPASS
		+SLIDESONWALLS
		-NOBLOCKMAP
	}
	States
	{
	Spawn:
		PROP A 3
		{
			A_CarNode();
		}
		Loop;
	See:
		TNT1 A 0;
		Goto Spawn;
	Pain:
		TNT1 A 0;
		Goto Spawn;
	Death:
		TNT1 A 0;
		Stop;
	}
}

//////////////////////////////////////////////
//////////////////////////////////////////////
//// Train node
//////////////////////////////////////////////
//////////////////////////////////////////////

class Postal_CarNode : PostalActor
{
	Actor NextNode, PreviousNode;
	int DynamicIncrease;
	
	int WarningTime;
	bool SpawnedMark;
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		DynamicIncrease = 0;
		WarningTime = level.time;
	
	}
	
	override void Tick()
	{
		Super.Tick();
		
		if (NextNode == null)
		{
			DynamicIncrease += 25;
		}
		
		//All nodes should be able to find their next nodes under 10 seconds
		if ((WarningTime + 35 * 20) < level.time)
		{
			if (NextNode == null)
			{
				if (SpawnedMark != true)
				{
					Console.Printf("Warning: Next Node for a path node hasn't been found. Marked with a confused Dude head.");
					spawn("Postal_FailedPathnode", self.pos+(0,0,50), ALLOW_REPLACE);
					if (PreviousNode != null)
						NextNode = PreviousNode;
					else
						NextNode = self;
						
					SpawnedMark = true;
				}
				
			}
		}
	}
	
	Default
	{
		//$Category Traffic
		//$Title "Car Pathnode"
		+NOGRAVITY;
		-SOLID;
		Radius 25;
		Height 25;
	}
	States
	{
	Spawn:
		PLSS AB 5
		{
			//Check if the NextNode actor pointer is null
			//Continously creating an iterator will degrade performance
			if (NextNode == null)
				A_SetNextNode();
		
		}
		Loop;
	}
	
	//It is sensitive to angle, so If you are placing them on a map make sure they are facing a node
	action void A_SetNextNode()
	{
		//many thanks to phantombeta!!
		double fov = 50; // this should be an argument, variable or constant instead, this is just here as an example
		BlockThingsIterator it = BlockThingsIterator.Create (self, invoker.DynamicIncrease); // 1024
		
		while (it.Next ()) {
				let next = it.Thing;
				if (!next) return;
				
				
				if (AbsAngle (AngleTo (next), angle) > (fov / 2.)) // Not within FOV
				{
					continue;
				}
				
				if (invoker.NextNode == null)
				{
					//Hopefully by the time the NPC approaches it's node it will already attach an actor pointer;
					if (next is 'Postal_CarNode' && next != self)
					{
							let node = Postal_CarNode(next);
							
							if (next != self)
								invoker.NextNode = next;
							
							node.PreviousNode = self;
					}
				}
						
			}
    }
}